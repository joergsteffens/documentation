////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
;
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Revision:  4.2
:toclevels: 6
:doctype:   book

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]


= opsi Getting Started opsi-Version 4.2

// Include common opsi terms
include::../common/opsi_manual_copyright.asciidoc[]

[[opsi-getting-started-introduction]]
== Einführung
Diese Anleitung beschreibt detailliert die Installation und Inbetriebnahme eines {opsi-Server}s, ausgehend von den zur Verfügung gestellten Installationspaketen bis zur Testinstallation eines Clients.

Die dargestellte Netzwerkkonfiguration ist exemplarisch und bezieht sich auf ein Netz u.a. ohne konkurrierende DHCP-Server (z.B. ein isoliertes Testnetz, in das der {opsi-Server} und seine Clients für die ersten Versuche gestellt werden können).

Wir empfehlen Ihnen dringend, erste Versuche mit opsi in einem Testnetz zu machen, das getrennt von anderen DHCP-Servern ist, welches Sie aber zeitweise an Ihr Hauptnetz ankoppeln können, um z.B. Aktualisierungen und Pakete aus dem Internet laden zu können

Für die Einbindung in bestehende Netze können Sie ggf. auf Beratungsleistungen durch uib zurückgreifen.

[[opsi-getting-started-introduction-first-steps]]
=== Die Schritte der Installation und Inbetriebnahme

Die Installation und Inbetriebnahme eines {opsi-Server}s erfolgt in vier Schritten:

. Grundinstallation des Servers

. Anpassung des Servers: Konfiguration des Netzwerks, Passwortvergabe, Aktualisierung des Servers

. Download und Installation der notwendigen opsi-Produkte für die Clients

. Vervollständigen der Betriebssystem-Basispakete für Windows von den Original-Medien

Danach kann bereits ein Client automatisch installiert werden. +
Für die Grundinstallation existieren mehrere Varianten, die je nach Interesse und Vorliebe genutzt werden können.
Die Verfahrensweisen bei den Varianten der Grundinstallation sind in Abschnitt <<opsi-getting-started-installation>> der vorliegenden Anleitung geschildert.

[[opsi-getting-started-introduction-hardware-preconditions]]
=== Hardwarevoraussetzungen

Für den {opsi-Server} in realer Hardware wird benötigt:

* Intel-x86-kompatibler PC

* mindestens 2GB RAM

* eine Festplatte mit mindestens 60 GB Kapazität

Im Testbetrieb sind die Anforderungen an die Leistungsfähigkeit der Maschine nicht besonders hoch. Für den Produktivbetrieb kann es nötig werden die Anforderungen an den Server an zu passen.

Bei der Verwendung der virtuellen Maschine muss ein angemessener Wirtsrechner genutzt werden. Es sollte mindestens ein Dualcore Prozessor und 4GB RAM vorhanden sein.
Für eine Teststellung kann problemlos eine weitere virtuellen Maschine auf dem selben Wirtsrechner als Client dienen.

[[opsi-getting-started-introduction-software-and-configuration-preconditions]]
=== Software und Konfigurationsvoraussetzungen

Folgende Voraussetzungen müssen erfüllt sein, damit Sie opsi installieren bzw. einsetzen können:

* *gültiger DNS Domainname* +
Ihr DNS Domainname muss mindestens aus einer Domain und einer Topleveldomain bestehen.
Anders ausgedrückt: der volle (Full qualified) Domainname muss mindestens einen Punkt enthalten.  Weiterhin muss die Topleveldomain aus mindestens zwei Zeichen bestehen. +
Erlaubt sind z.B.: 'domain.local', 'uib.de', 'subdomain.domain.de'. +
Nicht erlaubt ist z.B. 'mydomain.d', denn das wäre nur ein Zeichen in der Topleveldomain. +
Nicht erlaubt ist z.B. 'mydomain', denn das wäre nur eine Topleveldomain. +
Siehe auch: +
http://de.wikipedia.org/wiki/Domain +
http://de.wikipedia.org/wiki/Hostname#Richtlinien

* *gültige DNS Hostnamen* +
Die Hostnamen (auch der Clients) müssen den Richtlinien entsprechen.
Dazu gehört auch, dass sie z.B. keine Unterstriche enthalten dürfen. +
Siehe auch: +
http://de.wikipedia.org/wiki/Hostname#Richtlinien

* *Korrekte Namensauflösung für den Server* +
Prüfen Sie den Eintrag für den {opsi-Server} in der Datei '/etc/hosts', +
oder aber die Ausgabe von
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
Das Ergebnis sollte beispielsweise so aussehen: +
'192.168.1.1 server.domain.tld server' +
Sieht das Ergebnis nicht so aus (enthält z.B. '127.0.0.1' oder 'localhost'), dann müssen Sie Ihre '/etc/hosts' oder Namensauflösung zunächst korrigieren.

NOTE: Die Namen müssen den Vorgaben eines DNS-Systems entsprechen, aber ein DNS-Server wird für den Betrieb von opsi nicht benötigt.

NOTE: opsi benötigt kein _Active Directory_ oder ähnliches. Eine Integration ist möglich, wird aber nicht vorausgesetzt.

Die benötigten Network Ports finden Sie hier: <<opsi-getting-started-installation-config-ports>>


* *Gesetzte Spracheinstellungen* +
opsi setzt voraus, dass auf dem verwendeten Server Spracheinstellungen ('locale') gesetzt sind. +
Empfohlen wird die Verwendung einer UTF-8-kompatiblen Lokalisierung. +
+
Zur vereinfachten Prüfung kann folgender Befehl verwendet werden:
+
[source,prompt]
----
test -e /etc/default/locale && echo "ok" || (echo "Check locales:" && locale)
----
+
Wird _ok_ ausgegeben, so sind locales gesetzt.
Wird _check locales:_ ausgegeben, so prüfen Sie bitte, dass in der nachfolgend
ausgegebenen Liste für 'LANG' oder 'LC_ALL' ein Wert gesetzt ist, welcher der von
Ihnen verwendeten Sprache entspricht.
+
Für Deutsch empfehlen wir `de_DE.UTF-8`.
+
Die folgenden Befehle zeigen beispielhaft wie die Einstellung geändert
werden kann, sollte kein oder ein ungewollte Wert gesetzt sein:
+
[source,prompt]
----
sudo locale-gen de_DE.UTF-8
update-locale LANG=de_DE.UTF-8
----
+
Zum systemweiten Anwenden der Spracheinstellung sollte der Server neu gestartet werden.
+
Weitere Informationen entnehmen Sie bitte dem Handbuch der von Ihnen verwendeten Linux-Distribution.


[[opsi-getting-started-supportmatrix]]
== opsi Support Matrix (opsi läuft auf welchen Servern)

Im folgenden finden Sie eine Übersicht auf welchen Plattformen opsi
als Server läuft.

include::../common/opsi_manual_supportmatrix.asciidoc[]

[[opsi-getting-started-installation]]
== opsi-server Installation

[[opsi-getting-started-installation-base]]
=== {opsi-Server}-Grundinstallation

In diesem Abschnitt werden verschiedene Varianten der Realisierung des '{opsi-server}s' dargestellt.
Wenn alle Schritte klappen, erhalten Sie ein Serversystem, das bereit für die endgültige Konfiguration und Inbetriebnahme ist.
Sie haben also die Wahl und können die Abschnitte überspringen, die die nicht gewählten Wege zum {opsi-Server} beschreiben.

Wir empfehlen zur Evaluierung von opsi, den Weg über die vorinstallierte virtuellen Maschine zu wählen. +
Die Grundregel ist: wenn Sie der Reihe nach die Befehle in den

[source,prompt]
----
hervorgehobenen Feldern
----

ausführen (z.B. per cut&paste aus diesem Dokument holen), dann sollte die Installation auch funktionieren.

Falls in Ihrem Netzwerk ein Proxyserver zum Zugriff auf das Internet verwendet werden muss, so denken Sie daran diesen auch auf Ihrem {opsi-server} einzutragen.
Insbesondere die Umgebungsvariablen `http_proxy` und `https_proxy`.

Bei Problemen wenden Sie sich bitte an: https://forum.opsi.org


[[opsi-getting-started-installation-base-vm]]
==== Inbetriebnahme der von uib vorkonfigurierten virtuellen Maschine

Da die Anforderungen an die Rechengeschwindigkeit eher niedrig sind, lässt sich der '{opsi-server}' auch problemlos als virtuelle Maschine installieren.
Für ESX, VMware und  Virtualbox haben wir bereits eine entsprechende Maschine eingerichtet.
Die Dateien stehen im Internet zur Verfügung.
Zum Betrieb genügt ein kostenfreier VMware-Player oder Virtualbox.
Sie können diese Maschine aber auch in VMware-Server oder ESX betreiben.

[[opsi-getting-started-installation-base-vm-start]]
===== Auspacken und erster Start

*VMware*

Sofern Sie bereits über einen Gastrechner verfügen, auf dem die VMware-Vollversion oder ein VMware-Player installiert ist, erledigen Sie die Grundinstallation des '{opsi-server}s' mit wenigen Mausklicks:

* Laden Sie die aktuelle opsi-ServerVM von link:http://uib.de/de/opsi/opsi-testen-download/[uib.de]
* Entpacken Sie den Zip-File, das Verzeichnis `opsivm` wird erzeugt.
* Starten Sie den VMware-Player. +
Öffnen Sie "Open a Virtual Maschine", suchen Sie in dessen Dateiauswahldialog das Verzeichnis `opsivm` und darin die Datei `opsivm.ovf`. Gegebenenfalls müssen Sie ganz unten noch die anzuzeigenden Dateitypen auf ovf ändern.
Sie können den Server jetzt unter einem eigenen Namen importieren. Der virtuelle Server kann gestartete werden.

*ESXi-Server*

* Laden Sie die aktuelle opsi-ServerVM von link:http://uib.de/de/opsi/opsi-testen-download/[uib.de]
* Entpacken Sie den Zip-File, das Verzeichnis `opsivm` wird erzeugt
* Starten Sie den vSphere Client. +
Erstellen Sie sich einen neuen Rechner über 'Datei' / 'OVF-Vorlage bereitstellen....' und die Beantwortung der Folge-Dialoge.

*Virtualbox*

* Laden Sie die aktuelle opsi-ServerVM von link:http://uib.de/de/opsi/opsi-testen-download/[uib.de]
* Entpacken Sie den Zip-File, das Verzeichnis `opsivm` wird erzeugt
* Starten Sie Virtualbox. +
Über den Menüpunkt 'Datei' / 'Appliance importieren' können Sie die Datei `opsivm.ovf` laden.

*Allgemein*

Den VMware-Player können Sie für alle gängigen Betriebssysteme kostenfrei bei link:https://www.vmware.com/[vmware.com] beziehen.
Er lässt sich in der Regel problemlos installieren, sofern die Ausstattung des Wirtsrechners, insbesondere mit Speicher, den Bedarf mehrerer parallel laufender Betriebssysteme abdeckt.

[[opsi-getting-started-installation-base-vm-lang]]
===== Sprachauswahl
Nach dem Start des Systems müssen Sie die gewünschte Sprache auswählen:

.Sprachauswahl
image::abbildung1.png["Screenshot: Sprachauswahl",width=400]

[[opsi-getting-started-installation-base-vm-1stboot]]
=====  Erster Start

Zur Arbeit mit dem {opsi-Server} ist es von sehr großem Vorteil, wenn dieser direkt mit dem Internet verbunden ist. Zur Netzwerkkonfiguration wird beim ersten Start der Appliance automatisch das Skript `1stboot.py` aufgerufen. +
Wenn Sie das System anders aufgesetzt haben oder einen neuen Anlauf nehmen wollen, können sie `1stboot.py` bzw. `/usr/local/bin/1stboot.py` auch auf der Kommandozeile aufrufen.

Die Logdatei von `1stboot.py` ist `/var/lib/1stboot/1stboot.log`.

WARNING: `1stboot.py` eignet sich nicht, um einen konfigurierten {opsi-Server} nachträglich umzubenennen!

.Startmaske
image::abbildung2.png["Screenshot: 1stboot.py Startmaske",width=400]

Sie werden dann zur Eingabe von Informationen zur Konfiguration des Netzwerkes aufgefordert. Beantworten Sie die Fragen.

.Eingabemaske
image::1stboot-Eingabemaske.png["Screenshot: 1stboot Eingabemaske",width=400]

Im Folgenden werden Sie gefragt nach:

Servername:: Name diese Servers (ohne Domain) z.B. +opsidepot+

Domain:: DNS-Domain (nicht Windows-Domain, muss einen Punkt enthalten)
z.B. +opsi.local+ oder +meinefirma.local+

IP-Adresse:: Adresse dieses Servers z.B. +192.168.1.50+

Netzmaske:: Netzmaske dieses Servers z.B. +255.255.255.0+

Windows Domain:: Name der Windows Domain (nicht DNS-Domain)

Länderkennung::	Für die Erstellung des SSL-Zertifikats: Kennung der Nation in 2 Großbuchstaben, z.B. +DE+

Bundeslandkennung:: Für die Erstellung des SSL-Zertifikats: Kennung des Bundeslandes, z.B. +RPL+

Stadt::	Für die Erstellung des SSL-Zertifikats: Stadt, z.B. +Mainz+

Firma::	Für die Erstellung des SSL-Zertifikats: Firma, z.B. +uib gmbh+

Abteilung::	Für die Erstellung des SSL-Zertifikats (Optional)

Mail Adresse::	Für die Erstellung des SSL-Zertifikats(Optional): Mailadresse

Gateway::	IP-Adresse des Internetgateways, z.B. +192.168.1.1+

Proxy::	Soweit zum Internetzugriff benötigt, die Angaben zum Proxy: z.B. `http://myuser:mypass@192.168.1.5:8080`

DNS-Server::	IP-Adresse des Nameservers, z.B. +192.168.1.1+

Mailrelay::	IP-Adresse des Mailservers z.B. +192.168.1.1+

Tftpserver::	Als 'TFTP server' geben Sie in der Regel die IPv4-Adresse des Servers (='IP-Adresse') ein.

Passwort für root::	Das Passwort für den lokalen Administrator-Benutzer.

Passwort für adminuser::	Das Passwort für den lokalen opsi-Administrator.

Nach Abschluss des Programms `1stboot.py` wird die virtuelle Maschine, sofern Sie automatisch gestartet war, auch automatisch neu gebootet.


[[opsi-getting-started-installation-base-vm-second-start]]
===== Zweiter Start

Nach dem Neustart bzw. nach Fertigstellen der Netzwerkkonfiguration melden Sie sich als Benutzer +adminuser+ mit dem von Ihnen vergebenen Passwort an.

Sie befinden sich direkt auf der graphischen Oberfläche des '{opsi-server}s' (für diese wird ein Ressourcen schonender Windowsmanager verwendet).
Zur Begrüßung erscheint ein „Firefox“-Browser-Fenster mit dem Verweis auf das vorliegende Handbuch und weiteren Hinweisen.

Wenn die Meldung erscheint, dass keine Netzwerkverbindung verfügbar ist, kann dies mit der speziellen Start-Konfiguration der virtuellen Appliance zusammenhängen.
Vor einer weiteren Fehlersuche sollten Sie zunächst probieren, den Server nochmals zu rebooten (z.B. mit dem Ausschaltknopf in der Bedienleiste unten auf der graphischen Oberfläche).

.Graphische Startoberfläche des opsiservers
image::opsiserver_start_gui.png["Screenshot: Graphische Startoberfläche des opsiservers",400]

Sobald die Netzwerkkonfiguration funktioniert, können Sie auch remote auf den {opsi-Server} zugreifen:

* *Per ssh* +
(in Linux-Systemen stets vorhanden, unter Windows mit putty, s. http://www.chiark.greenend.org.uk/~sgtatham/putty/) +
kommen Sie auf die Kommandozeile des Servers. Als Benutzernamen verwenden Sie root, Sie  authentifizieren sich mit dem Root-Passwort.

[[opsi-getting-started-installation-base-vm-term]]
===== Terminalfenster

Im Folgenden müssen einige Befehle auf der Kommandozeile eingegeben werden.
Bei anderen ist die Eingabe der Befehle auf der Kommandozeile der schnellere Weg zum gewünschten Ergebnis.

Ein Fenster zur Text-Eingabe von Befehlen, d.h. ein Terminalfenster, erhält man auf verschiedenen Wegen:

* Remotezugriff per ssh auf den {opsi-Server} (s. vorheriger Abschnitt)

* Öffnen eines Terminalfensters in der graphischen Oberfläche (direkt auf dem {opsi-Server}) durch Klicken auf das Terminal-Icon in der Icon-Leiste der graphischen Oberfläche.

* Öffnen eines Terminalfensters in der graphischen Oberfläche (direkt auf dem {opsi-Server}) durch Rechtsklick in der Fläche und Auswahl von „Terminal“.
Dazu hilfreich: die graphische Oberfläche hat mehrere Arbeitsflächen, erreichbar durch die Auswahl-Schaltflächen in der linken oberen Bildschirmecke.

Besonders vorteilhaft ist es, Befehle aus den Anleitungen, z.B. diesem Handbuch, direkt  per Kopieren & Einfügen in ein Terminalfenster zu übertragen,
soweit die entsprechende Anwendungsumgebung dies unterstützt.

Beispiele aus Konfigurationsdateien sind in den Dokumentationen wie folgt formatiert:
[source,configfile]
----
depoturl = smb://smbhost/sharename/path
----

Befehle sind folgendermaßen hervorgehoben:
[source,prompt]
----
cd /tmp
ls -l
----

In '<spitzen Klammern>' werden Namen dargestellt, die durch ihre Bedeutung ersetzt werden müssen. +
Beispiel: Der Fileshare, auf dem die opsi Softwarepakete liegen, wird '<opsi-depot-share>' genannt und liegt auf einem realen Server in der Regel in '/var/lib/opsi/depot'. +
Das Softwarepaket: `<opsi-depot-share>/ooffice` liegt dann tatsächlich unter
`/var/lib/opsi/depot/ooffice`.

[[opsi-getting-started-installation-base-vm-network]]
===== Überprüfen und ggf. korrigieren der Netzwerkanbindung

Wenn die Netzwerkkonfiguration korrekt ist und der Rechner Anbindung an das Internet hat, können Sie mit dem Browser im Startfenster bereits auf eine beliebige Adresse im Internet zugreifen.

Sofern nicht alles funktioniert, öffnen Sie am besten ein Terminalfenster (möglicherweise geht es dann noch nicht remote, sondern nur auf der Server-Oberfläche), und prüfen die Netzwerkanbindung mit den üblichen, hier nicht zu erklärenden Checks.

Sie können im Terminalfenster auch das Kommando
[source,prompt]
----
1stboot.py
----

aufrufen und die Netzwerkkonfiguration neu eingeben.

Ein Systemneustart wird dann durch den Befehl

[source,prompt]
----
reboot
----

erzwungen.

Wenn die Netzwerkanbindung funktioniert, setzen Sie die Konfiguration des {opsi-Server}s fort, um dann mit ersten Installationstest beginnen zu können.

[[opsi-getting-started-installation-base-vm-update-server]]
===== Aktualisierung des opsi-Servers

Bringen Sie den opsi-Server auf den aktuellen Stand, indem Sie das Icon 'Update OS' auf dem Desktop doppelt klicken. Geben Sie das Passwort für den adminuser ein und bestätigen gegebenfalls mit 'Y' falls erforderlich.

[[opsi-getting-started-installation-base-vm-update-opsi-product]]
===== Installieren der Standard opsi-Produkte

Installieren Sie die Standard opsi-Produkte durch Doppelklick auf das Icon 'First package installation'. Bitte geben Sie das Passwort für den +adminuser+ ein.
Hierdurch werden automatisiert die aktuellen opsi-Pakete, incl. Templates für Betriebssysteminstallationen, aus den opsi-Repositories geholt und auf dem Server installiert.

Für weitere Informationen siehe auch <<opsi-getting-started-installation-config-get-essential-products>>.


[[opsi-getting-started-installation-base-vm-start-configed]]
===== Start der Management-Oberfläche

Die Management-Oberfläche können Sie durch einen Doppelklick auf das Icon 'opsi Management GUI' aufrufen.
Zur Beschreibung der Management-Oberfläche gehen Sie zu <<opsi-getting-started-installation-config-configed>>.

Damit ist die grundlegende Server-Konfiguration beendet.

Sie können nun fortfahren mit

* <<opsi-getting-started-firststeps-software-deployment-client-integration>>

* <<opsi-getting-started-firststeps-osinstall>>


[[opsi-getting-started-installation-base-deb]]
==== Installation auf einem Debian / Ubuntu System

In diesem Abschnitt wird davon ausgegangen, dass Sie mit dem Debian-Paketsystem vertraut sind (Informationen zu diesem Thema finden Sie in den einschlägigen Büchern, in den man-pages oder unter  http://www.debiananwenderhandbuch.de/).

Bitte beachten Sie, das ein {opsi-Server} im Verzeichnis '/var/lib/opsi' einen empfohlenen freien Speicher von mindestens 16 GB benötigt.

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.

Wir empfehlen zunächst folgende Installationen:

[source,prompt]
----
apt install wget host pigz
----

Weiterhin muss Samba installiert sein:

[source,prompt]
----
apt install samba samba-common smbclient cifs-utils
----

Der {opsi-Server} benötigt Zugriff auf einen Redis-Server ab Version 5 inklusive des RedisTimeSeries-Moduls (https://github.com/RedisTimeSeries/RedisTimeSeries).
Sie können einen bestehenden Redis-Server verwenden oder eine Redis-Instanz auf dem {opsi-Server} installieren:

[source,prompt]
----
apt install redis-server redis-timeseries
----

Nun sollten Sie den MySQL-Server installieren, damit Sie MySQL als Backend z.B. für die Inventarisierungsdaten und Lizenzmanagement verwenden können:

[source,prompt]
----
apt install mysql-server
----

Prüfen Sie den Eintrag für den {opsi-Server} in der Datei `/etc/hosts` oder aber die Ausgabe von

[source,prompt]
----
getent hosts $(hostname -f)
----

Das Ergebnis sollte beispielsweise so aussehen: +
'192.168.1.1 server.domain.tld server' +
Sieht das Ergebnis nicht so aus (enthält z.B. '127.0.0.1' oder 'localhost') dann müssen Sie Ihre '/etc/hosts' oder Namensauflösung zunächst korrigieren.

Um nun opsi zu installieren muss das opsi-Repository für apt eingetragen werden:

*Ubuntu 20.04 LTS _Focal Fossa_:*
[source,prompt]
----
echo "deb http://download.opensuse.org/repositories/home:/uibmz:/opsi:/4.2:/stable/xUbuntu_20.04/ /" > /etc/apt/sources.list.d/opsi.list
----

*Ubuntu 18.04 LTS _Bionic Beaver_:*
[source,prompt]
----
echo "deb http://download.opensuse.org/repositories/home:/uibmz:/opsi:/4.2:/stable/xUbuntu_18.04/ /" > /etc/apt/sources.list.d/opsi.list
----

*Debian 10 _Buster_:*
[source,prompt]
----
echo "deb http://download.opensuse.org/repositories/home:/uibmz:/opsi:/4.2:/stable/Debian_10.0/ /" > /etc/apt/sources.list.d/opsi.list
----

Führen Sie nun folgende Befehle aus, um den Signierschlüssel des Repositories zu importieren:

*Ubuntu 20.04 LTS _Focal Fossa_:*
[source,prompt]
----
wget -nv https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/xUbuntu_20.04/Release.key -O Release.key
apt-key add - < Release.key
----

*Ubuntu 18.04 LTS _Bionic Beaver_:*
[source,prompt]
----
wget -nv https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/xUbuntu_18.04/Release.key -O Release.key
apt-key add - < Release.key
----

*Debian 10 _Buster_:*
[source,prompt]
----
wget -nv https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/Debian_10.0/Release.key -O Release.key
apt-key add - < Release.key
----

Alle: +
Prüfen Sie ob der Import erfolgreich war:
[source,prompt]
----
apt-key list
----

sollte unter anderem enthalten: +
`pub   rsa2048 2017-09-30 [SC] [verfällt: 2021-11-30]
      2E98F7B5A5B2C8FE7F609705D1F933E6D8361F81
uid           home:uibmz:opsi OBS Project <home:uibmz:opsi@build.opensuse.org>`

Führen Sie nun folgende Befehle aus um opsi auf dem Server zu installieren:

[source,prompt]
----
apt update
apt remove tftpd
# Nur notwendig wenn eine tftp Zeile in der inetd Konfiguration vorhanden ist
update-inetd --remove tftp
apt install opsi-tftpd-hpa
apt install opsi-server
apt install opsi-windows-support
----

Falls Sie bei der Installation von opsi-tftp-hpa nach dem Tftp-Basisverzeichnis gefragt werden, beantworten Sie diese Frage mit `/tftpboot`.

Bei der Installation des {opsi-Server}s werden Sie gefragt, ob die `smb.conf` gepatcht werden darf. Beantworten Sie die Fragen mit 'Ja'.
Weiterhin werden Sie nach einem Passwort für den User pcpatch gefragt.
Vergeben Sie ein Passwort (und beachten Sie den folgenden Abschnitt zum Ändern der Passwörter).

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

[[opsi-getting-started-installation-base-ucs]]
==== Installation auf einem Univention Corporate Server (UCS)

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.


Die Installation auf einem Univention Corporate Server ist sowohl über das dort vorhandene App Center als auch auf klassischem Wege über die von uib gepflegten Repositories möglich.

Beides sind gleichwertige Installationsmöglichkeiten. Wir empfehlen pro Server nur jeweils eine davon zu verwenden.
Der Unterschied zwischen den Varianten ist, dass bei Verwendung des App Centers eine Installation auf der Rolle 'Member' nicht möglich ist.
Werden neue Betriebssystempakete veröffentlicht, so stehen diese bei der Verwendung der uib-Repositories schneller zur Verfügung als über das App Center.
Bei der Verwendung des App-Center wird der Wechsel auf eine neue UCS-Version (bspw. von UCS 4.2 nach UCS 4.3) vom Betriebssystem blockiert, bis alle Apps unter der neuen Betriebssystemversion zur Verfügung stehen.

NOTE: Aktuell werden Installationen auf einem System mit 32bit- und 64bit-Architektur untestützt. +
In Zukunft wird der Support für 32bit eingestellt, weshalb wir nur noch den Einsatz von 64bit empfehlen.

Allen Installationsvarianten ist gemein, dass das Paket `opsi4ucs` installiert wird.
Dieses bereitet die UCS-Umgebung auf den Einsatz mit opsi vor. Dazu wird ein Join-Script verwendet.
Die Vorbereitung beinhaltet das Anlegen von benötigten Benutzern, Gruppen und Freigaben.

Auf dem ersten {opsi-Server} in einer Umgebung wird das Backend zur Verwendung des vorhandenen MySQL-Servers konfiguriert.
Alle nachfolgenden Server werden in opsi als Depots registriert werden.

Wird von opsi 4.0 aktualisiert, so wird im Rahmen des Join-Scripts die Migration der Backends durchgeführt.


[[opsi-getting-started-installation-base-ucs-appcenter]]
===== Installation mittels Univention App-Center

Über das Univention App-Center steht eine automatisierte Installation des {opsi-server}s zur Verfügung.
Die Installations-App für opsi befindet sich in der UCS-Management-Oberfläche in der Kategorie 'System'.
Über das App-Center kann opsi nur auf den Rollen 'Master', 'Backup' und 'Slave' installiert werden.

Falls Sie ein Update einer vorhandenen opsi-Umgebung durchführen möchten, lesen Sie bitte auch das darauf folgende Kapitel.

Zur Installation des {opsi-server}s werden automatisch weitere Pakete installiert: 'opsi-tftpd-hpa', 'opsi-windows-support', 'univention-mariadb' bzw. 'univention-mysql'.

Falls ein existierender {opsi-server} entdeckt wird, so wird 'opsi-package-updater' so konfiguriert, dass er die Pakete von diesem Server bezieht.
Der 'opsi-package-updater' wird bei der Installation - nicht bei einer Aktualisierung - zum Einspielen der minimalen opsi-Produkte aufgerufen.
Im Rahmen eines Major- oder Minor-Update werden Paketaktualisierungen eingespielt.

Bitte beachten Sie, dass anschließend kein automatischer Transfer von Clients nach opsi stattfindet.
Mehr Informationen unter <<opsi-getting-started-installation-base-ucs-listener>>.

Die opsi-Installation auf einem UCS-Server über das 'Univention' App-Center ist damit abgeschlossen. Weiter geht es mit:
<<opsi-getting-started-installation-config-modules>>

[[opsi-getting-started-installation-upgrade-appcenter]]
===== Update vorhandener opsi-Installation von einem UCS 3 auf UCS 4 (über App-Center)

Eine der wichtigsten Änderungen, die mit dem Update für opsi 4.0.5 gekommen ist, ist die Unterstützung der Gruppe 'opsifileadmins'. Diese Gruppe ersetzt in UCS
zukünftig die Gruppe 'pcpatch'. 'Opsifileadmins' wurde zwar schon mit der
Unterstützung von UCS 3.0 eingeführt, es wurde allerdings nur auf
Installationen eingerichtet, die mit Samba 4 und den Univention
Directory Services (Samba4-AD) installiert wurden.
Auf allen anderen Varianten und Rollen, wurde bisher die Gruppe als
'pcpatch' angelegt. +
Da dieser Umstand nicht nur im Installationshandling ein Problem darstellt, sondern auch Probleme bei möglichen Migrationen (besonders von Samba3 auf Samba4) verursachen kann, wird seit opsi 4.0.5 die Gruppe 'pcpatch' als 'opsifileadmins' angelegt.

WARNING: Um diese Anforderungen sauber in das Integrationspaket implementieren zu können, wird die Gruppe 'pcpatch', falls vorhanden, automatisch über das Integrationspaket in 'opsifileadmins' umbenannt.
Dies geschieht über das join-Skript. Falls Ihr Configserver auf einem 'Master' oder 'Backup' betrieben wird, wird das Join-Skript automatisch ausgeführt. +
 +
Der Hauptgrund für diese drastische Maßnahme ist, dass die manuelle Umbenennung dieser Gruppe nicht trivial ist, da es sich um eine primäre Gruppe handelt. Wir empfehlen vor dem Einspielen dieses Updates zu überprüfen, ob Ihre Gruppe noch 'pcpatch' heißt. Wenn dem so ist, sollte das Update - angefangen beim Configserver - auf allen Depotservern zeitnah eingespielt werden, da ansonsten der Betrieb der Multidepot Umgebung gestört wird. Wenn Ihre Gruppe schon 'opsifileadmins'
heißt, sollten keine Beeinträchtigungen auftreten. Dennoch wird empfohlen, nach dem Einspielen der Updates alle opsi-Server auf Funktion zu überprüfen.


[[opsi-getting-started-installation-base-ucs-manually]]
===== Manuelle opsi-Installation unter UCS (ohne App-Center)

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.

Notwendige Vorbereitungen:

* Der Befehl
+
[source,prompt]
----
hostname -f
----
+
muss einen fully qualified domainname zurück liefern, in dem mindestens zwei Punkte vorkommen, z.B. 'opsiserver.domain.local'.

* Der Befehl
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
muss die IP-Adresse der Netzwerkschnittstelle zurück liefern, zu der sich die Clients verbinden sollen. Gibt der Befehl die Adresse '127.0.0.1' oder '127.0.0.2' aus, muss die Datei `/etc/hosts` korrigiert werden.

* Samba muss konfiguriert sein. Für den Einsatz auf einem Server in der Rolle 'Member' muss `univention-samba` anstatt `univention-samba4` zum Einsatz kommen.

* `univention-mariadb` oder `univention-mysql` muss installiert sein

* Soll die Maschine auch als DHCP-Server eingesetzt werden, muss der Daemon dhcpd konfiguriert und am Laufen sein.

Die Installation von opsi ist möglich auf den Rollen 'Master', 'Backup', 'Slave' und 'Member'.
Für die Installation auf einem 'Member' beachten Sie unbedingt <<opsi-getting-started-installation-base-ucs-member>>!

Die folgende Dokumentation geht von einer Installation auf der Rolle 'Master' mit Samba 4 aus.

CAUTION: Wird die Installation auf einem 'Slave' ausgeführt, muss dieser bereits gegenüber dem 'Master' gejoint und während der Grundinstallation Samba 4 installiert worden sein. +
Die UCS-Konfiguration wird überlicherweise auf dem 'Master' vorgenommen, während die Installation und Konfiguration von opsi auf dem 'Slave' geschieht.

Die klassischen Installationsvariante mit dem Benutzer: 'pcpatch' mit der primären Gruppe 'pcpatch' kann unter UCS nicht eingehalten werden. Da Samba4 den grundlegenden Restriktionen von Active-Directory unterliegt, sind Gruppen mit der gleichen Bezeichnung wie User (wie in Unix/Linux üblich) nicht mehr erlaubt.
Aus diesem Grund wurde für UCS 3 die neue Konfigurationsdatei `/etc/opsi/opsi.conf` eingeführt, über welche gesteuert wird, wie die Gruppe für den Samba-Zugriff auf die Freigaben bestimmt wird. Seit UCS 3 wird über diese Datei der Gruppenname 'pcpatch' umbenannt und heißt von nun an: 'opsifileadmins'.
Das bedeutet, dass die User, die Zugriffsrechte für die Freigaben von opsi erhalten müssen (opsi-Paketierer) nicht Mitglied der Gruppe 'pcpatch', sondern Mitglied der Gruppe 'opsifileadmins' sein müssen. Diese Besonderheit gilt nur für UCS und unterscheidet sich von den anderen Distributionen und in weiterführenden Kapiteln der opsi-Dokumentationen. Unter UCS wird der User 'pcpatch' als vollwertiger Domänenbenutzer angelegt.
Nähere Informationen über diese neue Konfigurationsdatei können Sie dem Handbuch entnehmen.

* Um opsi zu installieren, tragen Sie das entsprechende Repository ein:

*UCS 4.4:*
[source,prompt]
----
echo "deb http://download.opensuse.org/repositories/home:/uibmz:/opsi:/4.2:/stable/Univention_4.4/ /" > /etc/apt/sources.list.d/opsi.list
----

*UCS 4.3:*
[source,prompt]
----
echo "deb http://download.opensuse.org/repositories/home:/uibmz:/opsi:/4.2:/stable/Univention_4.3/ /" > /etc/apt/sources.list.d/opsi.list
----


Nun muss noch der Schlüssel des Repositories ins System importiert werden:

*UCS 4.4:*
[source,prompt]
----
wget -nv https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/Univention_4.4/Release.key -O Release.key
apt-key add - < Release.key
----

*UCS 4.3:*
[source,prompt]
----
wget -nv https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/Univention_4.3/Release.key -O Release.key
apt-key add - < Release.key
----


Für die Installation führen Sie nun folgende Befehle aus:

*UCS 4.4:*
[source,prompt]
----
univention-install univention-mariadb
univention-install opsi-tftpd-hpa opsi4ucs
univention-install opsi-windows-support
----

*UCS 4.3:*
[source,prompt]
----
univention-install opsi-tftpd-hpa
univention-install univention-mariadb
univention-install opsi4ucs
univention-install opsi-windows-support
----


Ist die Rolle des Zielsystems eine andere als 'Master' oder 'Backup', muss nun noch das opsi4ucs Join-Skript ausgeführt werden:

[source,prompt]
----
univention-run-join-scripts
----

Unter der URL `https://<servername>:4447` finden Sie nun einen Link zur opsi Management Oberfläche.

Um den opsi-Konfigurations-Editor verwenden zu können, muss ein Benutzer Mitglied der Gruppe {opsi-admin-group} sein. Die Gruppenzugehörigkeit eines Users kann über Univention-Admin bearbeitet werden. Der Benutzer Administrator wird während der Installation automatisch in diese Gruppe aufgenommen.

Abschliessend muss noch im UDM unter dem Punkt Freigaben für die 'opsi_depot' -Freigabe unter Erweiterte Einstellungen -> Erweiterte Samba-Einstellungen: Die Option: 'follow symlinks' auf 'yes' gesetzt werden. Das gleiche sollte man am besten auch für die 'opsi_depot_rw' -Freigabe erledigen, damit später die Treiberintegration keine Probleme verursacht. Sollte sich das `/var/lib/opsi/depot` -Verzeichnis auf einer extra Partition oder Festplatte befinden, muss man noch zusätzlich für diese Freigaben die Option wide links auf 'yes' setzen.

Um sicher zu stellen, dass alle Einstellungen von opsi nun korrekt übernommen wurden, sollte man noch folgende Befehle ausführen:

[source,prompt]
----
opsi-setup --init-current-config
opsi-set-rights
systemctl restart opsiconfd.service
systemctl restart opsipxeconfd.service
----

Bei samba4 handelt es sich um einen zentralen Dienst, daher wird dieser nicht automatisch vom Paket neugestartet, sondern muss nachträglich manuell durchgeführt werden. Nach dem Neustart von samba kann es zu einer kleinen Verzögerung beim Zugriff auf die neuen Freigaben kommen, wir bitten dies zu berücksichtigen.

Da es keinen direkten Kontakt zwischen Univention-LDAP und dem opsi-Backend gibt, müssen alle Clients erst im LDAP über udm angelegt werden und danach nochmal mit opsi im opsi-System mit allen Informationen (insbesondere der MAC-Addresse) angelegt werden. Das Löschen des Clients im Univention-LDAP sorgt nicht dafür, dass der Client unter opsi auch gelöscht wird.
Dieses Problem wird in  <<opsi-getting-started-installation-base-ucs-listener>> genauer beleuchtet.

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

WARNING: Die verwendeten Unix-Befehle in den folgenden Kapiteln beziehen sich auf Debian-Systeme, Sie müssen sie evtl. durch die entsprechenden UCS-Befehle ersetzen.

[[opsi-getting-started-installation-base-ucs-member]]
===== Hinweise zur opsi-Installation auf einem UCS-Server in der Rolle 'Member'

WARNING: Da der Einsatz von opsi auf 'Member'-Servern besonderen Einschränkungen unterliegt, empfehlen wir Anfängern den Einsatz von opsi auf einer anderen Rolle.

Die Installation von opsi auf einem Server in der Rolle 'Member' ist möglich.
Eine automatisierte Installation über das Univention App Center kann jedoch aktuell nicht vorgenommen werden.

Nach einer Installation muss sicher gestellt werden, dass der für den Depotzugriff verwendete Benutzer mitsamt Domäne aufgeführt ist.
Dazu muss der Hostparameter `clientconfig.depot.user` kontrolliert werden.
Ist die Domäne `backstage`, so muss der Wert `backstage\pcpatch` lauten. Lautet er `memberserver\pcpatch`, so muss der Wert korrigiert werden.

Das Setzen des Kennworts für den Benutzer `pcpatch` über `opsi-admin` scheitert auf Grund der fehlenden AD-Schreibberechtigungen eines 'Member'-Servers.
Daher muss die Änderung des Kennworts des technischen Benutzers `pcpatch` *zusätzlich* auf einem Server mit Schreibrechten im AD vorgenommen werden - ein 'Master', 'Backup' oder 'Slave'.


[[opsi-getting-started-installation-base-ucs-pxepolicy]]
===== Konfiguration des PXE-Boot für Betriebssysteminstallationen

Wenn der PXE-Boot für die Betriebssysteminstallation eingesetzt werden soll, muss der DHCP-Dienst auf dem entsprechenden UCS-System umkonfiguriert werden. Hier gibt es zwei Besonderheiten, die UCS von den anderen unterstützten Distributionen unterscheidet.

* Die Konfiguration wird nicht automatisch vorgenommen, da bei einer Installation von opsi in eine produktive UCS-Infrastruktur in der Regel schon diese Konfigurationen existieren.
* Ist der opsi-tftpd-hpa so konfiguriert, dass er nicht wie sonst das Verzeichnis `/tftpboot` als Basisverzeichnis nutzt, sondern `/var/lib/univention-client-boot`. Alle wichtigen Dateien vom {opsi-linux-bootimage} werden deshalb vom `/tftpboot` in das Basisverzeichnis verschobem. Dies hat den Nebeneffekt, dass die DHCP-Option: Filename `pxelinux.0` statt `linux/pxelinux.0` lauten muss.

Um die oben genannte Konfigurationen um zu setzen, muss im UCS-System eine Richtlinie erstellt werden. Diese Einstellung ist abhängig von den schon vorhandenen Richtlinien und müssen entsprechend umgesetzt werden. Wenn opsi auf einem UCS-Testsystem installiert wurde und keine Richtlinien entsprechend existieren, sollte erst geprüft werden ob der DHCP-Dienst installiert ist, wenn nicht muss das noch nachgeholt werden. Wenn der DHCP-Dienst schon installiert wurde, ist der einfachste Weg die Richtlinie in der UMC-Webschnittstelle (Univention Management Console) vom UCS-Server zu erstellen. Dazu wählt man den die Kategorie "Domäne" und darunter das Modul DHCP-Server. Als nächstes muss man den Service wählen (Bei einem Testsystem gibt es in der Regel nur einen Eintrag). In der folgenden Detailansicht wählt man den Menüpunkt Richtlinien. Die Richtlinie, die hier benötigt wird ist eine DHCP-Boot Richtlinie. Bei der Richtlinienkonfiguration wählt man nun den Defaulteintrag `cn=default-settings` (sollte der einzige Eintrag sein) und wählt bearbeiten. Unter Grundeinstellungen - DHCP Boot für die Option Bootserver die IP vom {opsi-server} ein und bei Boot-Dateiname muss `pxelinux.0` eingetragen werden.

WARNING: Wenn man die Richtlinie wie oben beschrieben setzt, gilt das für jedes Gerät, welches per DHCP von diesem Server bedient wird. Deshalb noch mal der Hinweis, dass diese Beschreibung nur für Evaluierer gedacht ist, die im Zuge von opsi auch ucs Testen. Bei Installationen in produktive UCS-Umgebungen sollte man diese Richtlinie nicht auf diese Weise setzen.

Optional lassen sich diese Einstellungen auch auf der Konsole mit dem udm-Kommando erledigen. Nähere Informationen dazu entnehmen Sie bitte der entsprechenden UCS-Dokumentation.


[[opsi-getting-started-installation-base-ucs-listener]]
===== LDAP-Daten nach opsi überführen

In einer opsi4ucs-Installation müssen die Windows-Clients erst im UDM angelegt werden und erst im folgenden Schritt im opsi-configed erstellt werden.
Änderungen von Clients im UDM werden nicht an opsi weitergegeben.
Wenn ein Client zum Beispiel im LDAP eine neue Mac-Addresse bekommt, wird dies im opsi-System nicht bemerkt.
Wenn man nun versucht ein Netboot-Produkt für diesen Client auf setup zu setzen, würde opsi die Bootkonfiguration mit der falschen Mac-Addresse im Bootsystem hinterlegen.

Die Lösung hierzu ist die Erweiterung 'opsi-directory-connector'.
Weitere Informationen hierzu enthält das Handbuch.

[[opsi-getting-started-installation-base-opensuse]]
==== Installation auf openSUSE

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.


Notwendige Vorbereitungen:

* Der Befehl
+
[source,prompt]
----
hostname -f
----
+
muss einen fully qualified domainname zurück liefern, in dem mindestens zwei Punkte vorkommen, z.B. 'opsiserver.domain.local'.

* Der Befehl
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
muss die IP-Adresse der Netzwerkschnittstelle zurück liefern, zu der sich die Clients verbinden sollen. Gibt der Befehl die Adresse '127.0.0.1' oder '127.0.0.2' aus, muss die Datei `/etc/hosts` korrigiert werden.

* Samba muss installiert und konfiguriert sein.

* MariaDB-Server muss installiert sein.

* Soll die Maschine auch als DHCP-Server eingesetzt werden, muss der Daemon dhcpd konfiguriert und am Laufen sein.

Hinzufügen des opsi-SUSE-Repositories per zypper:

*openSUSE Leap 42.3:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/openSUSE_Leap_42.3/home:uibmz:opsi:4.1:stable.repo
----

Nach dem Hinzufügen der Repositories kann die Installation gestartet werden:

[source,prompt]
----
zypper refresh
  Wollen Sie den Schlüssel (a)bweisen, ihm (t)emporär oder (i)mmer vertrauen? [a/t/i/?] (a): i
zypper -v install opsi-server
zypper -v install opsi-windows-support
----

Bitte stellen Sie sicher, daß Ihre Firewall Konfiguration die folgenden Ports erlaubt: tftp Port (69/UDP) und die opsi ports (4447/TCP und 4441/TCP).

Falls Sie die Netzwerkkonfiguration mit Hilfe der Tools yast oder autoyast vorgenommen haben kann es sein, dass dieses Tool einen Eintrag in die Datei `/etc/hosts` einen Eintrag nach folgendem Muster angelegt hat:
[source,configfile]
----
127.0.0.2 <fqdn> <hostname>
----

Falls Sie opsi die Konfiguration des DHCP Servers überlassen wollen muss dieser Eintrag auf die öffentliche IP-Adresse geändert werden, über die der Server erreichbar ist.

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

WARNING: Die verwendeten Unix-Befehle in den folgenden Kapiteln beziehen sich auf Debian-Systeme. Sie müssen sie durch die entsprechenden Suse-Befehle ersetzen.

[[opsi-getting-started-installation-base-sles]]
==== Installation auf Suse Linux Enterprise Server (SLES)

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.


Notwendige Vorbereitungen:

* Der Befehl
+
[source,prompt]
----
hostname -f
----
+
muss einen fully qualified domainname zurück liefern, in dem mindestens zwei Punkte vorkommen, z.B. 'opsiserver.domain.local'.

* Der Befehl
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
muss die IP-Adresse der Netzwerkschnittstelle zurück liefern, zu der sich die Clients verbinden sollen. Gibt der Befehl die Adresse '127.0.0.1' oder '127.0.0.2' aus, muss die Datei '/etc/hosts' korrigiert werden.

* Samba muss konfiguriert sein.

* `mariadb-server` sollte installiert sein.

* Soll die Maschine auch als DHCP-Server eingesetzt werden, muss der Daemon dhcpd konfiguriert und am Laufen sein.

Hinzufügen des opsi-SLES-Repositories per zypper:

*SLES 12SP4:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/SLE_12_SP4/home:uibmz:opsi:4.2:stable.repo
----

*SLES 12SP3:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/SLE_12_SP3/home:uibmz:opsi:4.2:stable.repo
----

*SLES 12SP2:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/SLE_12_SP2/home:uibmz:opsi:4.2:stable.repo
----

*SLES 12SP1:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/SLE_12_SP1/home:uibmz:opsi:4.2:stable.repo
----

*SLES 12:*
[source,prompt]
----
zypper addrepo http://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/SLE_12/home:uibmz:opsi:4.2:stable.repo
----

Nach dem Hinzufügen der Repositories kann die Installation gestartet werden:

[source,prompt]
----
zypper refresh
  Wollen Sie den Schlüssel (a)bweisen, ihm (t)emporär oder (i)mmer vertrauen? [a/t/i/?] (a): i
zypper -v install opsi-server
zypper -v install opsi-windows-support
----

Falls Sie die Netzwerkkonfiguration mit Hilfe der Tools yast oder autoyast vorgenommen haben kann es sein, dass dieses Tool einen Eintrag in die Datei `/etc/hosts` einen Eintrag nach folgendem Muster angelegt hat:
[source,configfile]
----
127.0.0.2 <fqdn> <hostname>
----

Fall Sie opsi die Konfiguration des DHCP Servers überlassen wollen muss dieser Eintrag auf die öffentliche IP-Adresse geändert werden, über die der Server erreichbar ist.

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

WARNING: Die verwendeten Unix-Befehle in den folgenden Kapiteln beziehen sich auf Debian-Systeme. Sie müssen sie durch die entsprechenden Suse-Befehle ersetzen.

[[opsi-getting-started-installation-base-rhel]]
==== Installation auf einem RedHat Enterprise Linux (RHEL)

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.

Notwendige Vorbereitungen:

* Der Befehl
+
[source,prompt]
----
hostname -f
----
+
muss einen fully qualified domainname zurück liefern, in dem mindestens zwei Punkte vorkommen, z.B. 'opsiserver.domain.local'.

* Der Befehl
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
muss die IP-Adresse der Netzwerkschnittstelle zurück liefern, zu der sich die Clients verbinden sollen. Gibt der Befehl die Adresse '127.0.0.1' oder '127.0.0.2' aus, muss die Datei '/etc/hosts' korrigiert werden.

* Samba und Datenbankserver installieren:
+
[source,prompt]
----
yum install redis-server redis-timeseries mariadb-server samba samba-client
----

* Samba und Datenbankserver konfigurieren:
+
[source,prompt]
----
systemctl start smb.service
systemctl start nmb.service
systemctl start mariadb.service
systemctl enable smb.service
systemctl enable nmb.service
systemctl enable mariadb.service
mysql_secure_installation
----

* Soll die Maschine auch als DHCP-Server eingesetzt werden, muss der Daemon dhcpd konfiguriert und am Laufen sein.

Beim Red Hat Network registrieren:

[source,prompt]
----
rhn_register
----

Hinzufügen des RHEL Repositories:

*RHEL 7:*
[source,prompt]
----
cd /etc/yum.repos.d/
wget https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/RHEL_7/home:uibmz:opsi:4.2:stable.repo
yum makecache
----


Nach dem Hinzufügen der Repositories kann die Installation gestartet werden:

[source,prompt]
----
yum remove tftp-server
yum install opsi-server
yum install opsi-windows-support
----

Es kann vorkommen, dass eine Nachfrage zum Importieren des GPG-Schlüssel des Repositories wie die nachfolgene Meldung während der Installation gezeigt wird:

[source,prompt]
----
   Importing GPG key 0xD8361F81 "home:uibmz OBS Project <home:uibmz@build.opensuse.org>" from http://download.opensuse.org/repositories/home:/uibmz:/opsi:/opsi4.2/RedHat_RHEL-6/repodata/repomd.xml.key
   Is this ok [y/N]: y
----
Bitte beantworten Sie diese Nachfrage mit 'y'.

Bitte stellen Sie sicher, dass Ihre iptables- und SELinux-Konfiguration die folgenden Ports erlaubt: tftp Port (69/UDP) und die opsi ports (4447/TCP und 4441/TCP).

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

WARNING: Die verwendeten Unix-Befehle in den folgenden Kapiteln beziehen sich auf Debian-Systeme. Sie müssen sie durch die entsprechenden RHEL-Befehle ersetzen.

[[opsi-getting-started-installation-base-centos]]
==== Installation auf einem CentOS Server

IMPORTANT: *Prüfen Sie hier ob Ihre Server Betriebssystem Version von opsi unterstützt wird:*
<<opsi-getting-started-supportmatrix>> +
Beachten Sie bitte die Software und Konfigurationsvoraussetzungen:  <<opsi-getting-started-introduction-software-and-configuration-preconditions>>.


Notwendige Vorbereitungen:

* Der Befehl
+
[source,prompt]
----
hostname -f
----
+
muss einen fully qualified domainname zurück liefern, in dem mindestens zwei Punkte vorkommen, z.B. 'opsiserver.domain.local'.

* Der Befehl
+
[source,prompt]
----
getent hosts $(hostname -f)
----
+
muss die IP-Adresse der Netzwerkschnittstelle zurück liefern, zu der sich die Clients verbinden sollen. Gibt der Befehl die Adresse '127.0.0.1' oder '127.0.0.2' aus, muss die Datei '/etc/hosts' korrigiert werden.

* Samba und Datenbankserver installieren:
+
[source,prompt]
----
yum install mariadb-server samba samba-client
----

* Samba und Datenbankserver konfigurieren:
+
[source,prompt]
----
systemctl start smb.service
systemctl start nmb.service
systemctl start mariadb.service
systemctl enable smb.service
systemctl enable nmb.service
systemctl enable mariadb.service
mysql_secure_installation
----

* Soll die Maschine auch als DHCP-Server eingesetzt werden, muss der Daemon dhcpd konfiguriert und am Laufen sein.

Hinzufügen des CentOS Repositories:

*CentOS 8:*
[source,prompt]
----
cd /etc/yum.repos.d/
wget https://download.opensuse.org/repositories/home:uibmz:opsi:4.2:stable/CentOS_8/home:uibmz:opsi:4.2:stable.repo
yum makecache
----

Nach dem Hinzufügen der Repositories kann die Installation gestartet werden:

[source,prompt]
----
yum install opsi-server
yum install opsi-windows-support
----

Es kann vorkommen, dass eine Nachfrage zum Importieren des GPG-Schlüssel des Repositories wie die nachfolgene Meldung während der Installation gezeigt wird:

[source,prompt]
----
   Importing GPG key 0xD8361F81 "home:uibmz OBS Project <home:uibmz@build.opensuse.org>" from http://download.opensuse.org/repositories/home:/uibmz:/opsi:/opsi4.2/CentOS_CentOS-6/repodata/repomd.xml.key
   Is this ok [y/N]: y
----
Bitte beantworten Sie diese Nachfrage mit 'y'.

Bitte stellen Sie sicher, dass Ihre iptables- und SELinux-Konfiguration die folgenden Ports erlaubt: tftp Port (69/UDP) und die opsi ports (4447/TCP und 4441/TCP).

Da Sie opsi auf einer existierenden Maschine eingespielt haben, gehen wir davon aus, dass Ihre Netzwerkkonfiguration korrekt ist. +
Machen Sie daher mit dem Punkt <<opsi-getting-started-installation-config-backend>> weiter.

WARNING: Die verwendeten Unix-Befehle in den folgenden Kapiteln beziehen sich auf Debian-Systeme, Sie müssen sie durch die entsprechenden CentOS-Befehle ersetzen.

[[opsi-getting-started-installation-config]]
=== Aktualisieren und Konfigurieren des {opsi-Server}s

[[opsi-getting-started-installation-config-proxy]]
==== Proxy-Eintrag in apt-Konfiguration

Sofern für Ihren Internet-Zugang erforderlich, passen Sie die Datei `/etc/apt/apt.conf` an Ihre Netzwerkgegebenheiten an (richtigen Proxy eintragen oder Zeile auskommentieren / löschen). Eine Datei können Sie editieren z. B. mithilfe des Programms „midnight commander“:

[source,prompt]
----
mcedit /etc/apt/apt.conf
----

[[opsi-getting-started-installation-config-update]]
==== Aktualisierung des {opsi-Server}s

Bringen Sie den {opsi-Server} auf den letzten Stand, in dem Sie nacheinander in einem Terminalfenster die folgenden Kommandos aufrufen:

[source,prompt]
----
apt update
apt upgrade
----

TIP: Sollte beim Update nachgefragt werden, ob die `smb.conf` überschrieben werden soll, muss man dies bestätigen. Sollte die `smb.conf` vorher schon geändert worden sein, sollte man den default beibehalten und später die Dateien miteinander abgleichen. Sollte diese Nachfrage schon mit Nein beantwortet worden sein, kann man dies später auf dem {opsi-Server} durch ausführen von `opsi-setup --auto-configure-samba` nachholen.


[[opsi-getting-started-installation-config-backend]]
==== Backend-Konfiguration

Opsi unterstützt zur Datenhaltung unterschiedliche Backends.

Im Wesentlichen sind dies:

* *file* - Datenhaltung in Dateien
* *mysql* - Datenhaltung in einer MySQL-Datenbank

Daneben gibt es noch für spezielle Zwecke die Backends:

* *opsipxeconfd* - der Dienst für den Netzwerkboot mit opsi
* *dhcpd* - zur Kommunikation mit dem dhcp-Server auf dem {opsi-server}
* *jsonrpc* - zur Weiterleitung aller Anfragen an einen anderen Server


Standardmäßig wird das {mysql-Backend} für die Inventarisierung verwendet.
Die Verwendung des {file-Backend}s für Inventurdaten ist möglich, aber deutlich langsamer und deshalb nicht empfohlen.

NOTE: Die Verwendung des {mysql-Backend} für Inventariserungsdaten ist kostenlos. +
Mehr Informationen zur Freischaltung finden Sie <<opsi-getting-started-installation-config-modules, hier>>.

NOTE: Einige Distributionen verwenden _MariaDB_ anstatt _MySQL_. +
Das _mysql_-Backend funktioniert auch mit MariaDB.


CAUTION: MySQL-Server verwendet seit Version 5.7 den vorher optionalen 'strict mode' nun standardmäßig. +
Dies führt zu einem Fehlschlag des Befehls `opsi-setup --configure-mysql`. +
Dementsprechend sollte vor dem Befehlsaufruf die Datei `/etc/mysql/mysql.conf.d/mysqld.cnf` editiert werden. +
In der `[mysqld]` Sektion muss nun folgende Zeile eingefügt werden: +
`sql_mode=NO_ENGINE_SUBSTITUTION` +
 +
Danach muss der Dienst `mysql` neu gestartet werden: `systemctl restart mysql.service`


Nachfolgend wird das {mysql-Backend} zur Verwendung eingerichtet.
Es wird davon ausgegangen, dass ein MySQL-Server eingerichtet wurde und die Zugangsdaten eines Datenbank-Administrators bekannt sind.
Gezielte Informationen zu Installation und Einrichtung entnehmen Sie bitte den Handbüchern Ihrer Distribution.

Für die initiale Konfiguration des {mysql-Backend}s nutzen Sie den Befehl:
[source,prompt]
----
opsi-setup --configure-mysql
----

Der Befehl wird nach den Zugangsdaten zum Datenbanksystem fragen, um eine Datenbank und einen Benutzer mit entsprechenden Berechtigungen für diese Datenbank für opsi anzulegen.

Eine Beispiel-Sitzung:

.opsi-setup --configure-mysql: Eingabemaske
image::mysql-config-input-mask.png["opsi-setup --configure-mysql: Eingabemaske",width=400]

.opsi-setup --configure-mysql: Ausgabe
image::mysql-config-output.png["opsi-setup --configure-mysql: Ausgabe",width=400]

Bei den Abfragen können außer beim 'Database Admin Password' alle Vorgaben mit Enter bestätigt werden.
Das 'Database Admin Password' ist auf der opsi-VM `linux123` ansonsten das, was Sie bei der Installation des mysql-servers vergeben haben.

Unterschiedliche Daten können in unterschiedlichen Backends gehalten werden.
Über bestimmte Vorgänge müssen mehrere Backends informiert werden.
Hierzu werden die opsi-Methoden den Backends zugeordnet.
Dies geschieht in der Datei `/etc/opsi/backendManager/dispatch.conf`.

Hier ein Beispiel:
[source,configfile]
----
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =      backend dispatch configuration                                     =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
#
# This file configures which methods are dispatched to which backends.
# Entries has to follow the form:
# <regular expression to match method name(s)> : <comma separated list of backend name(s)>
#
# Backend names have to match a backend configuration
# file basename <backend name>.conf beneath /etc/opsi/backends.
# For every method executed on backend dispatcher
# the first matching regular expression will be decisive.

# Recommended standard configuration (dhcpd not at the opsi server)
#    file as main backend, mysql as hw/sw invent
#     and license management backend and opsipxeconfd backend:
backend_.*         : file, mysql, opsipxeconfd
host_.*            : file, opsipxeconfd
productOnClient_.* : file, opsipxeconfd
configState_.*     : file, opsipxeconfd
license.*          : mysql
softwareLicense.*  : mysql
audit.*            : mysql
.*                 : file
----

In dieser Datei sind oben Erläuterungen und Beispielkonfigurationen angegeben.
In den nicht auskommentierten Zeilen steht vorne der Name der opsi-Methoden (mit wildcard `.*`) und nach einem Doppelpunkt die hierfür zuständigen Backends.
Bei jedem Methodenaufruf wird anhand dieser Liste geprüft, welche Backends aufgerufen werden müssen.
Dabei wird die erste Zeile genommen die zu dem Methoden Namen passt.
Die letzte Zeile (`.*`) passt auf jeden Methoden Namen.

Die Standardeinstellung bei der Installation von opsi die Verwendung  des {file-Backend}s als Haupt-Backend und Verwendung des {mysql-Backend} für Lizenzmanagement- und Inventur-Daten.

CAUTION: Achten Sie darauf, dass alle verwendeten Backends in der Zeile beginnend mit `backend_.*` aufgeführt werden.

Wann immer Sie die Datei `dispatch.conf` angepasst haben, führen Sie die folgenden Befehle aus.
Auch wenn Sie bei der Inbetriebnahme des Servers die Datei nicht geändert haben, führen Sie diese Befehle jetzt aus.

[source,prompt]
----
opsi-setup --init-current-config
opsi-set-rights
systemctl restart opsiconfd.service
systemctl restart opsipxeconfd.service
----


[[opsi-getting-started-installation-config-passwords]]
==== Samba-Konfiguration anpassen und Ändern von Passwörtern

Um sicherzustellen, dass die für opsi erforderlichen Samba-Shares verfügbar sind, führen Sie bitte den folgenden Befehl aus:

[source,prompt]
----
opsi-setup --auto-configure-samba
----

Anschließend sollten die Samba-Dienste neu gestartet werden:

[source,prompt]
----
systemctl restart smbd.service
systemctl restart nmbd.service
----

Auf dem System ist ein Pseudo-User 'pcpatch' eingerichtet. Die PCs melden sich zwecks Installation von Softwarepaketen als dieser User an und haben dann Zugriff auf die Installationsdateien auf den hierfür vorgesehenen Shares. Der User 'pcpatch' muss mit korrektem Passwort – gleichzeitig als System-User, als Samba-User und als opsi-User – eingerichtet werden.

Rufen Sie in einem Terminalfenster das Programm '{opsi-admin}' mit der Option zum Setzen des pcpatch-Passwortes (in einem für opsi, Unix und Samba).

[source,prompt]
----
opsi-admin -d task setPcpatchPassword
----

Nach „Abschicken“ des Befehls werden Sie zur Passworteingabe aufgefordert.


[[opsi-getting-started-installation-config-java]]
==== Überprüfung der Java-Konfiguration

Zur Verwaltung des {opsi-Server}s und der angeschlossenen Clients dient das Programm {opsi-configed}.
Es kommuniziert über HTTPS mit dem opsi-Server und kann daher auf jedem Rechner verwendet werden, der eine entsprechende Verbindung aufbauen kann.
Dieses Programm benötigt auf den Rechnern, auf denen es ausgeführt wird,
eine Java-Runtime-Umgebung mindestens in Version 8 bzw., wie die interne Versionszählung lautet, Version 1.8.

Wenn Sie das opsi Managementinterface '{opsi-configed}' direkt auf dem Server ausführen möchten, so benötigen Sie dort eine grafische Oberfläche und ein aktuelle Java Laufzeitumgebung.
Kann oder soll der {opsi-configed} nicht auf dem Server ausgeführt werden, können Sie dieses Kapitel überspringen. +

Eine grafische Oberfläche und eine aktuelle Laufzeitumgebung sind in der virtuellen Maschine von uib bereits installiert.

Kontrollieren Sie, ob Java in der benötigten Version installiert ist, indem Sie in einem Terminal den folgenden Befehl aufrufen:

[source,prompt]
----
java -version
----

Installieren Sie eine neuere Java-Version, falls die angezeigte Version zu alt ist.


TIP: Achten Sie bei einer virtuellen Maschine auf eine ausreichende Auflösung des virtuellen Bildschirms.
Für den {opsi-configed} ist es sinnvoll, eine Auflösung ab 1024x768 zu verwenden.
Für die Verbesserung der Graphik- und Maustreiberintegration bei einer höheren Auflösung, hilft es, die 'VMware Tools' bei einer VMware-Maschine bzw. die Gasterweiterungen bei einer VirtualBox-Maschine zu installieren.


[[opsi-getting-started-installation-config-users-and-groups]]
==== User einrichten und Gruppen opsiadmin und pcpatch pflegen

Die Administration von opsi ist nur Benutzern gestattet, die Mitglied der Unix-Gruppe '{opsi-admin-group}' sind.

Im folgenden wird als Beispiel der neue Benutzer 'adminuser' so eingerichtet, wie Sie ihn sich einrichten sollten.

Zunächst wird der User erstellt:

[source,prompt]
----
useradd -m -s /bin/bash adminuser
----

Wir vergeben nun Passwörter für Unix:

[source,prompt]
----
passwd adminuser
----

und für Samba

[source,prompt]
----
smbpasswd -a adminuser
----

CAUTION: Verwenden Sie in den Passwörtern kein '§' da dies bei der Verbindung zum opsi-Service nicht erlaubt ist.

Nun wird die Gruppenmitgliedschaft eingerichtet und getestet mit der Befehlsfolge:

[source,prompt]
----
usermod -aG opsiadmin adminuser
getent group opsiadmin
----

Der getent-Befehl sollte dann so etwas ausgeben wie:
[source,prompt]
----
opsiadmin:x:1001:opsiconfd,adminuser
----

NOTE: Wenn 'root' nicht Mitglied von {opsi-admin-group} ist, kann er unter Umständen nicht alle opsi-Administrationskommandos ausführen! +

Für alltägliche Arbeiten auf Ihrem opsi-Server ist es in der Regel nicht notwendig
als 'root' zu arbeiten.
Unsere Empfehlung ist es einen normalen Benutzer zu nutzen und `sudo` zu verwenden,
wann immer administrative Privilegien benötigt werden.

Alle User, die Produkte packen (`opsi-makepackage`), installieren (`opsi-package-manager`) oder Konfigurationsdateien manuell bearbeiten wollen, müssen zusätzlich in der Gruppe 'pcpatch' sein:

[source,prompt]
----
usermod -aG pcpatch adminuser
----

Der Test

[source,prompt]
----
getent group pcpatch
----
ergibt +
'pcpatch:x:992:adminuser'

Damit Mitglieder der Gruppe 'pcpatch' den Befehl `sudo opsi-set-rights` nutzen können führen Sie bitte aus:
[source,prompt]
----
opsi-setup --patch-sudoers-file
----

Dann kann `opsi-set-rights` (macht das selbe wie `opsi-setup --set-rights`),
nicht nur als root, sondern auch per sudo von Mitgliedern der Gruppe pcpatch (bzw. opsifileadmins) aufgerufen werden. +

Beispiel: +
[source,prompt]
----
sudo opsi-set-rights .
----


[[opsi-getting-started-installation-config-dhcp]]
=== DHCP-Konfiguration

Eine korrekt funktionierende Namensauflösung und DHCP ist für das Funktionieren von opsi essentiell.
Um die Installation zu vereinfachen, ist die von uib bereitgestellte VM schon mit einem DHCP-Server ausgestattet.
Auf der anderen Seite ist in vielen Umgebungen in der Regel bereits ein DHCP-Server schon vorhanden, der weiter genutzt werden soll.
Daher werden im folgenden beide Alternativen beschrieben.


[[opsi-getting-started-installation-config-dhcp-at-opsi]]
==== Alternative: DHCP auf dem {opsi-Server}

.Vorkonfigurierte VM:
In der vorkonfigurieren opsi VM ist bereits ein DHCP-Server installiert. +
Der DHCP-Server auf der {opsi-Server} VM ist so konfiguriert, das er keine freien leases hat, also keine IP-Nummern an unbekannte Rechner vergibt. Wenn Sie im {opsi-configed} einen Client erzeugen, müssen Sie daher IP-Nummer und MAC-Adresse angeben, da diese in die `/etc/dhcp/dhcpd.conf` eingetragen und danach der DHCP Dienst neu gestartet wird.

.Eigene Installation:
Wenn Sie den opsi-Server als DHCP-Server verwenden möchten, müssen Sie daher das entsprechende Paket manuell nachinstallieren

z.B. mit
[source,prompt]
----
apt install isc-dhcp-server
----

Nach der Installation muss die Konfigurationsdatei noch angepasst werden mit dem Befehl:
[source,prompt]
----
opsi-setup --auto-configure-dhcpd
----
Um den DHCP Server neu zu starten, so wie in `/etc/opsi/backends/dhcpd.conf` beschrieben,  ist ein entsprechender Eintrag in der `/etc/sudoers` notwendig. Dieser wird mit folgendem Befehl erstellt.
[source,prompt]
----
opsi-setup --patch-sudoers-file
----
Die Rechte der `/etc/dhcp/dhcpd.conf` sollten wie folgt aussehen.
[source,prompt]
----
-rw-r--r-- 1 opsiconfd opsiadmin 80174 Dec 22 14:37 /etc/dhcp/dhcpd.conf
----
[[opsi-getting-started-installation-config-at-other-server]]
==== Alternative: externer DHCP-Server

.Vorkonfigurierte VM:

Wenn Sie die opsi-VM verwenden dann können Sie den DHCP-Server deinstallieren.

Dazu führen Sie den folgenden Befehl aus:
[source,prompt]
----
apt remove isc-dhcp-server
----

.Eigene Installation:
Bei einer eigenen Installation wird seit opsi 4.0.3 nicht mehr automatisch ein DHCP-Server installiert.

Nun müssen Sie den externen DHCP-Server so konfigurieren, dass er ein PXE-Boot über den {opsi-Server} ermöglicht. Wenn Ihr DHCP-Server auf einem Linux läuft, sind folgende Einträge in der Konfigurationsdatei des dhcpd (z.B. `/etc/dhcp/dhcpd.conf`) für die Clients notwendig:

[source,configfile]
----
next-server <ip of opsi-server>;
filename "linux/pxelinux.0";
----

Wobei '<ip of opsi-server>' durch die IP-Adresse des {opsi-Server}s zu ersetzen ist.

Läuft der opsi-Server auf openSUSE oder SLES, so ist `filename=opsi/pxelinux.0`. +
Läuft der opsi-Server auf UCS, so ist `filename=pxelinux.0`.

Bei einem Windows-Server sind die entsprechenden Einträge 'Startserver (Option 66)' und 'Startfile (Option 67)'.

Wenn Sie im {opsi-configed} einen Client erzeugen, müssen Sie die MAC-Adresse angeben, aber keine IP-Nummer.


[[opsi-getting-started-installation-config-dhcp-backend]]
==== Überprüfung/Anpassung Backendkonfiguration für DHCP-Nutzung

Je nachdem ob der interne oder ein externer DHCP-Server verwendet wird, muss die Konfiguration von opsi angepasst werden.

In der Datei `/etc/opsi/backendManager/dispatch.conf` ist festgelegt, welche Backends von opsi zum Einsatz kommen (bspw. 'file', 'mysql').

In den Zeilen `backend_.*` und `host_.*` wird u.a. gesteuert, ob der {opsi-Server} auch die lokale DHCP-Konfiguration – also die Zuweisung von Internet-Adressen zu den Hardware-Adressen der Netzwerkkarten – mit übernimmt.
Dies muss so eingerichtet sein, wenn für die {opsi-Client}s die DHCP-Einträge durch die opsi-Konfigurationsaufrufe erzeugt werden sollen. Der entsprechende Eintrag mit `file` Backend muss dann z.B. lauten:
[source,configfile]
----
backend_.*         : file, opsipxeconfd, dhcpd
host_.*            : file, opsipxeconfd, dhcpd
----

Wenn der {opsi-Server} den DHCP-Dienst nicht bereitstellen soll (weil ein anderer Server im lokalen Netz diese Aufgabe übernimmt und auch für die {opsi-Client}s gepflegt wird), so wird das Backend `dhcpd` nicht benötigt:

[source,configfile]
----
backend_.*         : file, opsipxeconfd
host_.*            : file, opsipxeconfd
----

Nach Anpassung der Backendkonfiguration muss die Konfiguration initialisiert und der {opsiconfd} neu gestartet werden:

[source,prompt]
----
opsi-setup --init-current-config
opsi-set-rights
systemctl restart opsiconfd.service
systemctl restart opsipxeconfd.service
----


[[opsi-getting-started-installation-config-nameresolution]]
=== Konfiguration der Namensauflösung

Für die Installation der Software auf den Clients vor dem Login müssen allgemein nur die Clients wissen, wie sie den {opsi-Server} erreichen.

opsi kennt inzwischen allerdings auch eine Reihe von 'Push' Funktionalitäten wie z.B. 'on_demand' Installationen, Nachrichten versenden, Remote-Control Software starten, Session Informationen abrufen.

Für all diese Funktionen muss der Server die Clients erreichen können und dazu muss er die gültige IP-Nummer des Clients zu ermitteln. Wie dies am besten geschieht hängt von der konkreten Konfiguration von DNS und DHCP ab. Die Zahl der möglichen Varianten ist hier sehr groß.

Daher seien hier zwei typische Extreme aufgeführt:

. Die Clients sind nicht im DNS und haben dynamisch zugewiesene wechselnde IP-Nummern.

. Die IP-Nummern aller laufenden Clients lassen sich immer korrekt beim DNS abfragen.

Um den opsi-server nun an die unterschiedlichen Gegebenheiten anpassen zu können gibt es zwei Konfigurationen die Sie ändern können:

* Der Eintrag +resolveHostAddress+ in der Datei `/etc/opsi/backends/hostcontrol.conf` +
Steht diese Option auf 'True', wird bei einem Verbindungsaufbau vom {opsi-server} zu einem opsi-client die IP-Adresse des Clients bevorzugt über die Namensauflösung ermittelt. Um die im Backend von opsi hinterlegte IP-Adresse zu bevorzugen ist die Option auf 'False' zu setzen.

* Der Eintrag +update-ip+ in der Datei `/etc/opsi/opsiconfd.conf` +
Steht dieser Eintrag auf 'true', so wird wann immer der opsi-server von einem Client eine IP-Adresse empfängt (z.B. bei jedem Kontakt die der Client aufnimmt) die IP-Datenbank des opsi-servers aktualisiert. Der Default ist 'true'.

Für die oben aufgeführte Variante 1, ist es sinnvoll +resolveHostAddress+ auf 'False' und +update-ip+ auf 'true' zu setzen.

Für die oben aufgeführte Variante 2, ist die bessere Konfiguration  +resolveHostAddress+ auf 'True' zu setzen und +update-ip+ auf 'false'.

Welche Kombination bei Ihnen am besten passt, müssen Sie anhand Ihrer Gegebenheiten selbst ermitteln.

Wenn Sie an diesen Konfigurationen etwas geändert haben, so starten Sie den opsiconfd neu:

[source,prompt]
----
systemctl restart opsiconfd.service
----


[[opsi-getting-started-installation-config-get-essential-products]]
=== Einspielen der minimalen opsi-Produkte

Zur Verteilung von Software mit opsi stehen fertige Produkte zur Installation bereit.
Diese beinhalten unter anderem den Agent, welcher für das Management auf Clients installiert werden muss.

Es gibt eine automatische und manuelle Möglichkeit dies zu tun.
Der automatisierte Weg wird empfohlen.

Hierzu gibt es das Werkzeug `opsi-package-updater`, welches wie in '/etc/opsi/opsi-package-updater.conf' konfiguriert, automatisch die aktuellen Pakete vom opsi Repository holt und auf dem Server installiert.

[source,prompt]
----
opsi-package-updater -v install
----

Muss für den Zugriff auf das Internet die Verbindung über einen Proxy geleitet werden, so muss dieser in den `.repo`-Konfigurationsdateien unter `/etc/opsi/package-updater.repos.d/` als Wert für `proxy` eingetragen werden.
Ab Version 4.1.1.33 von opsi-utils kann ein globaler Proxy in `/etc/opsi/opsi-package-updater.conf` konfiguriert werden.

[source,configfile]
----
[repository_uib_windows]
…
proxy =
----

Sollen später installierte Pakete aktualisiert werden, so kann dies mit dem folgenden Befehl gemacht werden:
[source,prompt]
----
opsi-package-updater -v update
----

Weitere Informationen zum `opsi-package-updater` können im Handbuch gefunden werden.

NOTE: Bitte beachten Sie, dass OS-Installationsprodukte wie z.B. {opsi-client-os}, nach der Installation nicht sofort einsatzbereit sind. Die Installation muss noch durch die Installationsdateien des entsprechenden Installationsmediums ergänzt werden (siehe: <<opsi-getting-started-firststeps-osinstall-fill-base-packages>>).

[[opsi-getting-started-installation-config-get-essential-products-manually]]
=== Manuelles Einspielen der opsi-Produkte

Es gibt außerdem die Möglichkeit manuell die Pakete herunter zu laden und zu installieren.

Holen Sie sich die aktuellen opsi-Pakete im `.opsi`-Paketformat.
Die Pakete finden Sie unter http://download.uib.de/opsi4.1/stable/packages/windows/ in den Verzeichnissen `netboot/`, `localboot/`, für Linux-Clients zusätzlich unter `https://download.uib.de/opsi4.1/stable/packages/linux/`.

Wir empfehlen die .opsi-Dateien unter `/var/lib/opsi/repository` zu speichern.
Zum Sicherstellen, dass opsiconfd auf die Dateien zugreifen kann, sollte `opsi-set-rights /var/lib/opsi/repository` ausgeführt werden.

Nach dem Download müssen Sie die Pakete auf dem Server mit dem Befehl `opsi-package-manager -i <paketname>.opsi` installiert werden

[[opsi-getting-started-installation-config-modules]]
=== Einspielen / Überprüfen der Freischaltdatei

Auch wenn opsi Opensource ist, so gibt es einige Zusatz-Komponenten, die im Rahmen eines Kofinanzierungsprojektes erstellt wurden und evtl. noch nicht Opensource bzw. noch nicht kostenlos sind. Sobald die Entwicklungskosten eingenommen sind, werden auch diese Module Opensource bzw. kostenlos sein. Um bis dahin die Verwendung dieser Module den zahlenden Kunden und zu Evaluierungszwecken zu gestatten, gibt es die Freischaltdatei `/etc/opsi/modules`, welche durch eine elektronische Signatur vor unautorisierter Veränderung geschützt ist. Ist diese Datei nicht vorhanden, so funktionieren nur die 'freien' Module von opsi.

Um zu Evaluierungszwecken eine zeitlich befristet gültige Freischaltdatei zu erhalten, wenden Sie sich an info@uib.de. Im Rahmen einer Beteiligung an den entsprechenden Kofinanzierungsprojekten erhalten Sie eine unbefristet gültige Freischaltdatei. Diese können Sie mit root-Rechten nach /etc/opsi kopieren.

Führen Sie danach den folgenden Befehl aus:

[source,prompt]
----
opsi-set-rights
----

Kontrollieren Sie die Freischaltung mit einer der folgenden Methoden:

Im {opsi-configed} können Sie sich über den Menüpunkt 'Hilfe/opsi-Module' den Status Ihrer Freischaltung anzeigen lassen.

Mit der Methode `backend_info` können Sie mit `opsi-admin` überprüfen, welche Module freigeschaltet sind. (Hinweis: Geben Sie die weder die Datei noch die Ausgabe dieses Befehls öffentlich weiter, zumindest nicht ohne die Signatur zu löschen).
[source,prompt]
----
opsi-admin -d method backend_info
----

Beispiel-Ausgabe:
[source,configfile]
----
{
"opsiVersion" : "4.0.1",
"modules" :
          {
          "customer" : "uib GmbH",
          "vista" : true,
          "vpn" : true,
          "license_management" : true,
          "expires" : "never",
          "valid" : true,
          "multiplex" : true,
          "signature" : "DIES-IST-KEINE-ECHTE-SIGNATUR",
          "treeview" : true,
          "mysql_backend" : true
          }
}
----

Wir weisen darauf hin, dass die modules-Datei nur für zusätzliche Funktionalitäten benötigt wird und diese nicht für den „normalen“ Betrieb von opsi benötigt wird.


[[opsi-getting-started-installation-config-configed]]
=== Start der Management-Oberfläche ({opsi-configed})

Opsi bietet mit dem {opsi-configed} ein komfortables Management Interface.

Das Management Interface wird als lokale Anwendung auf den Administrations-PCs installiert.
Rufen Sie in Ihrem Browser die Adresse `https://<opsidepotserver>:4447/` auf.
Dort finden Sie Links zu Installern für unterschiedliche Betriebssysteme.

Alternativ finden Sie entsprechende Installer unter link:https://download.uib.de/opsi4.1/misc/helper/[].

IMPORTANT: Der Windows-Installer muss mit administrativen Rechten ausgeführt werden.
Dazu öffnen Sie mit Rechtsclick das Contextmenü des Installers und wählen dort 'Als Administrator ausführen'.

Ist ein PC mit dem Management Interface ausgestattet, so können weitere PCs später einfach über das Localboot-Produkt *opsi-configed* mit dem Interface ausgestattet werden.

Loggen Sie sich als ein User ein, der Mitglied der Gruppe {opsi-admin-group} ist.

Die Bedienung des Management-Interfaces ist weitgehend selbsterklärend.
Sie finden eine ausführliche Anleitung im opsi-Handbuch.

NOTE: Änderungen im opsi-Management Interface müssen gespeichert werden, bevor Sie wirksam werden und Veränderungen der Daten müssen vom Server über 'Daten neu laden' geholt werden.


[[opsi-getting-started-installation-config-ports]]
=== Von opsi benötigte Netzwerk-Ports

Dies ist eine Übersicht über verwendete Ports und Netzwerk-Protokolle.

* opsi-server Webservice: TCP 4447 +
Client zum Server, Depot zum Server (bidirektional, Verbindungen via localhost).

* opsi-client Webservice: TCP 4441 +
Server zum Client, Verbindung vom Client an sich selbst via localhost.

* opsi-client Webservice: TCP 4442 +
Verbindung vom Client an sich selbst via localhost.

* opsi-client Notifier: TCP 45000 - 65536 +
Verbindung vom Client an sich selbst via localhost. +
Ein zufälliger Port aus dem gegebenen Bereich wird ausgewählt.

* TFTP: UDP 69 +
Client zu Server.

* CIFS/SMB: UDP 137 / UDP 138 (netbios) / TCP 139 / TCP 445 +
Client zu Server (bidirektional). +
Abhängig von der Version des Client-Betriebssystems.

* WEBDAV: TCP 80
* WINEXE: UDP 137 / UDP 138 (netbios) / TCP 139 / TCP 445
Server zu Client (bidirektional). +
Abhängig von der Version des Client-Betriebssystems.

* SSH (optional): TCP 22

* DNS: TCP 53

* WakeOnLan (WOL): UDP 7 / UDP 9 / UDP 12287 +
Server zum Client. Diese Ports sind konfigurierbar.

* HTTP: TCP 80 +
Z.B. Um Server updates von http://download.opensuse.org/ zu laden

* HTTPS: TCP 443 +
Um updates von https://download.uib.de zu laden (opsi-package-updater)


[[opsi-getting-started-firststeps-software-deployment-client-integration]]
== Integration vorhandener Windows-Clients in opsi

Um vorhandene Windows-Clients in opsi aufzunehmen, muss auf diesen der {opsi-client-agent} installiert werden. Dies kann auf mehrere Arten durchgeführt werden. Nach dem Sie wie im Folgenden beschrieben den {opsi-client-agent} installiert haben, erscheint der Client auch in der Client-Liste des {opsi-configed}.

Danach können vorhandene opsi-Produkte auf diesen Clients installiert werden.

=== Installation des opsi-client-agent

[[opsi-getting-started-firststeps-software-deployment-client-integration-service-setup]]
==== Verwendung von service_setup.cmd

Diese Methode dient zur Installation auf einzelnen Rechnern. Für ein Massen-Rollout siehe weiter unten.

[[opsi-getting-started-firststeps-software-deployment-client-integration-service-setup_nt6]]
===== service_setup.cmd auf Windows NT6


. Loggen Sie sich mit administrativen Rechten auf dem Client ein.
. Mounten Sie den share `\\<opsiserver>\opsi_depot` auf einen Laufwerksbuchstaben.
. Starten Sie das Script `opsi-client-agent\service_setup.cmd` +
Starten Sie da Script nicht elevated (also rechte Maustaste: 'als Administrator') sonst kann das Script evtl. nicht gestartet werden, da eine elevated Prozess kein Zugriff auf ein Netzlaufwerk hat.
. Das Skript kopiert die notwendigen Dateien in ein temporäres lokales Verzeichnis und startet dann zur eigentlichen Installation opsi-script (winst32.exe) elevated. Daher bekommen Sie an dieser Stelle evtl. eine UAC Anfrage.
. Das Skript nimmt per opsi-Webservice Kontakt zum Server auf um serverseitig den Client zu erzeugen und den pckey zu erfahren. Dies erfolgt zunächst mit der in der config.ini eingetragenen user/password Kombination. Schlägt dies fehl, so erscheint ein Login-Fenster mit Service-URL ({opsi-configserver}), Benutzername und Passwort. Hier wird ein Benutzer benötigt, der Mitglied der Gruppe 'opsiadmin' ist. Möglich ist auch ein Benutzer, welcher nur die Methode `host_createOpsiClient` ausführen darf.

CAUTION: Der Client rebootet nach der Installation.

[[opsi-getting-started-firststeps-software-deployment-client-integration-service-setup_nt5]]
===== service_setup_NT5.cmd auf Windows NT5


. Loggen Sie sich mit administrativen Rechten auf dem Client ein.
. Mounten Sie den share `\\<opsiserver>\opsi_depot` auf einen Laufwerksbuchstaben.
. Starten Sie das Script `opsi-client-agent\service_setup_NT5.cmd`
. Das Skript kopiert die notwendigen Dateien in ein temporäres lokales Verzeichnis und startet dann zur eigentlichen Installation opsi-script (winst32.exe).
. Das Skript nimmt per opsi-Webservice Kontakt zum Server auf um serverseitig den Client zu erzeugen und den pckey zu erfahren. Dies erfolgt zunächst mit der in der config.ini eingetragenen user/password Kombination. Schlägt dies fehl, so erscheint ein Login-Fenster mit Service-URL ({opsi-configserver}), Benutzername und Passwort. Hier wird ein Benutzer benötigt, der Mitglied der Gruppe 'opsiadmin' ist.

CAUTION: Der Client rebootet nach der Installation.

[[opsi-getting-started-firststeps-software-deployment-client-integration-opsi-deploy]]
==== Verwendung von opsi-deploy-client-agent

Das `opsi-deploy-client-agent` Skript verteilt den {opsi-client-agent} direkt vom {opsi-server} auf die Clients. Voraussetzung hierfür sind bei den Clients:

* ein offener c$ share
* ein offener admin$ share
* ein administrativer account

Auf dem Server muss das Programm `winexe` vorhanden sein.
Eine statisch gelinkte winexe in Version 1.0 ist Teil des {opsi-client-agent}.

Winexe ist teilweise über die Paketquellen der verwendeten Distribution verfügbar.
Für einige Distributionen können Sie unter http://download.opensuse.org/repositories/home:/uibmz:/winexe/ eine aktuellere Version finden, welche auch das Deployment zu aktuellen NT6-Clients ermöglicht.
Falls Sie für Ihre Distribution keine Pakete finden oder selbst eine aktuelle Version des Programms erstellen wollen, so finden Sie weitere Informationen dazu auf der Projektseite unter http://sourceforge.net/projects/winexe/.

Das Skript erzeugt serverseitig den Client, kopiert die Installations-Dateien und Konfigurationsinformationen, wie bspw. den pckey, auf den Client und startet dort die Installation.

Das Kopieren der Installationsdateien kann auf zwei Wegen geschehen.
Die erste Variante wird mittels 'mount' C$ auf dem Server verfügbar machen und dort die Daten zur Installation hin kopieren.
Die zweite Variante wird den c$-Share des Clients mittels 'smbclient'
auf dem Server einhängen und dann die Installationsdateien dorthin
kopieren.

Mit dem `opsi-deploy-client-agent` Skript kann auch eine ganze Liste von Clients bearbeitet werden.
Dazu können entweder beliebig viele Clients als letzter Parameter übergeben werden oder mit der Option '-f' die Clients aus einer Datei eingelesen werden.
Bei der Verwendung einer Datei, muss in jeder Zeile ein Client stehen.

Das Script kann mit IP-Adressen, Hostnamen und FQDNs arbeiten. Es wird versuchen automatisch zu erkennen welche Art von Adresse übergeben wurde.

Mit dem `opsi-deploy-client-agent` Skript kann auch eine ganze List von Clients bearbeitet werden. Das Skript findet sich unter `/var/lib/opsi/depot/opsi-client-agent` +
Führen Sie das Script mit 'root' Rechten aus.
Falls das Script nicht ausführbar ist, so können Sie dieses Problem mit dem folgenden Befehl beheben: +
`opsi-set-rights /var/lib/opsi/depot/opsi-client-agent/opsi-deploy-client-agent`

[source,prompt]
----
bonifax:/home/uib/oertel# cd /var/lib/opsi/depot/opsi-client-agent
bonifax:/var/lib/opsi/depot/opsi-client-agent# ./opsi-deploy-client-agent --help
usage: opsi-deploy-client-agent [-h] [--version] [--verbose]
                                [--debug-file DEBUGFILE] [--username USERNAME]
                                [--password PASSWORD]
                                [--use-fqdn | --use-hostname | --use-ip-address]
                                [--ignore-failed-ping]
                                [--reboot | --shutdown | --start-opsiclientd]
                                [--hosts-from-file HOSTFILE]
                                [--skip-existing-clients]
                                [--threads MAXTHREADS] [--smbclient | --mount]
                                [--keep-client-on-failure | --remove-client-on-failure]
                                [host [host ...]]

Deploy opsi client agent to the specified clients. The c$ and admin$ must be
accessible on every client. Simple File Sharing (Folder Options) should be
disabled on the Windows machine.

positional arguments:
  host                  The hosts to deploy the opsi-client-agent to.

optional arguments:
  -h, --help            show this help message and exit
  --version, -V         show program's version number and exit
  --verbose, -v         increase verbosity (can be used multiple times)
  --debug-file DEBUGFILE
                        Write debug output to given file.
  --username USERNAME, -u USERNAME
                        username for authentication (default: Administrator).
                        Example for a domain account: -u
                        "<DOMAIN>\\<username>"
  --password PASSWORD, -p PASSWORD
                        password for authentication
  --use-fqdn, -c        Use FQDN to connect to client.
  --use-hostname        Use hostname to connect to client.
  --use-ip-address      Use IP address to connect to client.
  --ignore-failed-ping, -x
                        try installation even if ping fails
  --reboot, -r          reboot computer after installation
  --shutdown, -s        shutdown computer after installation
  --start-opsiclientd, -o
                        start opsiclientd service after installation
  --hosts-from-file HOSTFILE, -f HOSTFILE
                        File containing addresses of hosts (one per line).If
                        there is a space followed by text after the address
                        this will be used as client description for new
                        clients.
  --skip-existing-clients, -S
                        skip known opsi clients
  --threads MAXTHREADS, -t MAXTHREADS
                        number of concurrent deployment threads
  --smbclient           Mount the client's C$-share via smbclient.
  --mount               Mount the client's C$-share via normal mount on the
                        server for copying the files. This imitates the
                        behaviour of the 'old' script.
  --keep-client-on-failure
                        If the client was created in opsi through this script
                        it will not be removed in case of failure. (DEFAULT)
  --remove-client-on-failure
                        If the client was created in opsi through this script
                        it will be removed in case of failure.
----

[[opsi-getting-started-firststeps-software-deployment-product-tests]]
=== Rollout existierender Produkte

[[opsi-getting-started-firststeps-software-deployment-product-tests-configed]]
==== Verwendung von opsi Standard Produkten: opsi-configed

Zu den Standard Produkten gehört das Produkt `opsi-configed` welches das opsi Managementinterface als Anwendung auf einem Rechner installiert. Da diese Anwendung eine Java-Anwendung ist, wird ein JavaRE mitgeliefert.

Wählen Sie im '{opsi-configed}', Modus 'Client-Konfiguration', unter dem Reiter 'Clients' den betreffenden Client aus.

Wenn noch nicht geschehen, aktualisieren Sie den Datenbestand des {opsi-configed}s mittels 'Datei/Daten neu laden' bzw. Anklicken des entsprechenden Icons.

Wechseln Sie zum Reiter 'Produktkonfiguration', klicken Sie in die Spalte 'Angefordert' für das Produkt +opsi-configed+, daraufhin öffnet sich eine Liste/Dropdown-Menü und dort wählen Sie die Aktion 'setup'.

Der Haken in der Icon-Menüleiste sollte seine Farbe auf Rot wechseln. Wenn Sie ihn anklicken, werden die neuen Einstellungen zum {opsi-Server} übermittelt, im Anschluss ist seine Farbe wieder grün.

Booten Sie dann den Client. Er sollte jetzt den +opsi-client-agent+ starten und das Produkt +opsi-configed+ installieren. Nach Abschluß der Installation sollten Sie im `Startmenü` den Punkt `opsi-configed` finden.


[[opsi-getting-started-firststeps-software-deployment-product-tests-inventory]]
==== Inventarisierung mit dem localboot-Produkten hwaudit und swaudit

Wählen Sie im '{opsi-configed}', Modus 'Client-Konfiguration', unter dem Reiter 'Clients' den betreffenden Client aus.

Wenn noch nicht geschehen, aktualisieren Sie den Datenbestand des {opsi-configed}s mittels 'Datei/Daten neu laden' bzw. Anklicken des entsprechenden Icons.

Wechseln Sie zum Reiter 'Produktkonfiguration', klicken Sie in die Spalte 'Angefordert' für das Produkt +hwaudit+, daraufhin öffnet sich eine Liste/Dropdown-Menü und dort wählen Sie die Aktion 'setup'. Wiederholen Sie das für das Produkt +swaudit+.

Der Haken in der Icon-Menüleiste sollte seine Farbe auf Rot wechseln. Wenn Sie ihn anklicken, werden die neuen Einstellungen zum {opsi-Server} übermittelt, im Anschluss ist seine Farbe wieder grün.

Booten Sie dann den Client. Er sollte jetzt den +opsi-client-agent+ starten und die Produkte +hwaudit+ und +swaudit+ installieren. Bei +hwaudit+ und +swaudit+ wird Hard- bzw Softwareinformationen erhoben und zum {opsi-Server} übermittelt. Die gesammelten Informationen werden unter den Tabs 'Hardwareinformationen' bzw. 'Software-Inventur' angezeigt.

[[opsi-getting-started-firststeps-software-deployment-product-tests-hwinvent]]
==== Hardware-Inventarisierung mit dem netboot-Produkt hwinvent

Sofern Sie bereits einen Client eingerichtet haben und das Produkt +hwinvent+ installiert ist, können Sie bereits etwas Nützliches mit opsi tun:

Wählen Sie im {opsi-configed}, Modus Client-Konfiguration, unter dem Reiter Client-Auswahl den betreffenden Client aus. Wenn noch nicht geschehen, aktualisieren Sie den Datenbestand des {opsi-configed}s mittels Datei/Daten neu laden bzw. Anklicken des entsprechenden Icons. Wechseln Sie zum Reiter 'Netboot-Produkte', gehen Sie in das Feld 'Anstehende Aktion' des Produkts +hwinvent+ und wählen Sie in der dort angebotenen Liste die Aktion 'setup'. Der Haken in der Icon-Menüleiste sollte seine Farbe auf Rot wechseln. Wenn Sie ihn anklicken, werden die neuen Einstellungen zum {opsi-Server} übermittelt, im Anschluss ist seine Farbe wieder grün.

Booten Sie dann den Client. Er sollte jetzt per PXE über das Netz ein Linux-Image ziehen, das die Hardware des PCs scannt und dann den Rechner rebootet (wenn der Rechner nicht ansonsten schon eingerichtet war, kommt im Anschluss korrekterweise die Meldung, dass auf der Platte kein Betriebssystem installiert ist).

Das Ergebnis des Hardware-Scans hat der PC zum {opsi-Server} übermittelt. Es ist unter dem Reiter "Hardware-Informationen" einzusehen.

NOTE: Sollte nach dem Laden des Bootimages der Bildschirm schwarz bleiben oder die Netzwerkkarte nicht (korrekt) funktionieren, so muss für diese konkrete Hardware evtl. die Startparameter des Bootimages angepasst werden. +
Dies können Sie im '{opsi-configed}' im Tab 'Hostparameter' am Eintrag 'opsi-linux-bootimage.append' tun. Details hierzu finden Sie im opsi-manual im Kapitel 'Netboot Produkte'.


[[opsi-getting-started-firststeps-osinstall]]
== Installation eines neuen Windows PC über opsi (OS-Installation)

Nachfolgend wird beschrieben, wie ein bisher nicht mit einem Betriebssystem ausgestatter Computer per opsi ein Windows-Betriebssystem installiert bekommt.

Als Client-PC eignen sich reale oder virtuelle Rechner mit mindestens 2048 MB RAM, die über eine Netzwerkkarte mit Netzwerkboot-Unterstützung verfügen:
D.h., sie unterstützen das PXE-Protokoll zum Laden von Boot-Systemen via Netzwerk.
Der Netzwerkboot ist ggf. im Bios-Menü zu aktivieren bzw. an die erste Stelle der Bootoptionen zu rücken.

Virtuelle Hardware wird in der Regel gut von den Windows-Standardtreibern unterstützt, wenn Sie später eine Testinstallation von Windows durchführen.
Zur Installation von Windows auf neueren realen Rechnern müssen Sie möglicherweise vorab zusätzliche Treiber integrieren.
Für einen ersten Tests können Sie eine link:http://download.uib.de/vmware_pxeclient.zip[VMware-Appliance] verwenden, die einen _leeren_ Rechner abbildet und in _VMware Workstation Player_ laufen kann.

NOTE: Einige für die Bereitstellung von Windows mit opsi nützliche Werkzeuge werden über das Paket 'opsi-windows-support' installiert.


[[opsi-getting-started-firststeps-osinstall-create-client-configed]]
=== Anlegen eines neuen opsi-Clients über die Management Oberfläche

Existiert der Client, muss er in opsi hinzugefügt werden.
Dies kann nach Belieben per grafischer Oberfläche oder per Kommandozeile geschehen.


.Per grafischer Oberfläche:

Den Client können Sie mit der grafischen Oberfläche {opsi-configed} zum {opsi-Server} hinzufügen.

Wählen Sie den Menü-Punkt 'OpsiClient / Neuen opsi-Client erstellen' und geben Sie ein:

* Client-Name
* DNS Domäne (falls abweichend von der Vorgabe)
* Beschreibung
* IP-Adresse (wird benötigt, falls kein DNS zur Namensauflösung für diesen Client verwendet werden kann)
* MAC-Adresse (wird benötigt, falls der {opsi-Server} DHCP-Server ist oder PXE boot mit dem Client durchgeführt werden soll).

Nach Eingabeabschluss wird der Client dem {opsi-Server} bekanntgemacht und gleichzeitig, falls der {opsi-Server} DHCP Server ist, in der DHCP-Konfiguration als PXE-Client angelegt.

Die Liste der eingerichteten opsi-Clients kann jederzeit im {opsi-configed} Modus „Client-Konfiguration“ unter dem Reiter Client-Auswahl eingesehen werden.


.Per Kommandozeile:

Ein Client kann auf der Kommandozeile per `opsi-admin` erzeugt werden.

Die Syntax ist die folgende:
[source,prompt]
----
opsi-admin -d method host_createOpsiClient <client-id> [opsiHostKey] [description] [notes] [hardwareAddress] [ipAddress] [inventoryNumber] [oneTimePassword] [created] [lastSeen]
----

Fehlende Werte verwenden in der Regel einen Standardwert - die meisten Felder sind dann leer.


Der folgende Befehl wird den Client `testclient.domain.local` mit einem zufälligen Host Schlüssel,
der Beschreibung `Testclient`, keinen Notizen, der MAC-Addresse `00:0c:29:12:34:56` und der IP-Adresse `192.0.2.1` anlegen:

[source,prompt]
----
opsi-admin -d method host_createOpsiClient testclient.domain.local "null" "Testclient" "" 00:0c:29:12:34:56 192.0.2.1
----


[[opsi-getting-started-firststeps-osinstall-tests-hwinvent]]
==== Hardware-Inventarisierung mit dem netboot-Produkt hwinvent

Sofern Sie bereits einen Client eingerichtet haben und das Produkt 'hwinvent' installiert ist, können Sie bereits etwas Nützliches mit opsi tun:

Wählen Sie im {opsi-configed}, Modus 'Client-Konfiguration', unter dem Reiter Client-Auswahl den betreffenden Client aus. Wenn noch nicht geschehen, aktualisieren Sie den Datenbestand des {opsi-configed}s mittels Datei/Daten neu laden bzw. Anklicken des entsprechenden Icons. Wechseln Sie zum Reiter 'Netboot-Produkte', gehen Sie in das Feld "Anstehende Aktion" des Produkts "hwinvent" und wählen Sie in der dort angebotenen Liste die Aktion "setup". Der Haken in der Icon-Menüleiste sollte seine Farbe auf Rot wechseln. Wenn Sie ihn anklicken, werden die neuen Einstellungen zum {opsi-Server} übermittelt und die Farbe des Hakens wechselt im Anschluss wieder zu grün.

Booten Sie dann den Client. Er sollte jetzt per PXE über das Netz ein Linux-Image ziehen, das die Hardware des PCs scannt und dann den Rechner rebootet (wenn der Rechner nicht ansonsten schon eingerichtet war, kommt im Anschluss korrekterweise die Meldung, dass auf der Platte kein Betriebssystem installiert ist).

Das Ergebnis des Hardware-Scans hat der PC zum {opsi-Server} übermittelt. Es ist unter dem Reiter "Hardware-Informationen" zu besichtigen.

NOTE: Sollte nach dem Laden des bootimages der Bildschirm schwarz bleiben oder die Netzwerkkarte nicht (korrekt) funktionieren, so muss für diese konkrete Hardware evtl. die Startparameter des bootimages angepasst werden. +
Dies können Sie im '{opsi-configed}' im Tab 'Hostparameter' am Eintrag 'opsi-linux-bootimage.append' tun. Details hierzu finden Sie im opsi-manual im Kapitel 'Netboot Produkte'.


[[opsi-getting-started-firststeps-osinstall-create-client-bootcd]]
=== Anlegen eines neuen opsi-Clients mit Hilfe der opsi-client-bootcd

Auf der Downloadseite von uib finden Sie unter https://download.uib.de/opsi4.1/boot-cd/ verschiedene ISO-Abbilder der opsi-client-boot-cd. Laden Sie sich das Neueste herunter und brennen es auf eine CD. Starten Sie den Rechner von der CD. Sie sollten dann folgendes Bild sehen:

.Startbild opsi-client-boot-cd
image::opsi-client-boot-cd.png["Screenshot: Startbild opsi-client-boot-cd",width=400]

Wählen Sie 'Opsi starten'. Nach einer Weile wird folgender Bildschirm erscheinen. Wenn Ihr DHCP-Server IP-Adressen an unbekannte Rechner vergibt ist die Maske schon weitgehend ausgefüllt. Ansonsten müssen Sie es von Hand tun. In der Regel müssen Sie mindestens den Hostnamen vergeben.

.bootimage/boot-cd Konfigurationsmakse
image::boot-cd-config.png["Screenshot: bootimage/boot-cd Konfigurationsmaske",width=400]

Wählen Sie dann 'ok'.

.bootimage/boot-cd Auswahl Erstellungsmethode
image::boot-cd-select.png["Screenshot: bootimage/boot-cd Auswahl Erstellungsmethode",width=200]

Wählen Sie dann 'Admin account'. Sie erklären damit, dass der Client sich selbst beim {opsi-server} anmelden und erstellen soll. Dieser Vorgang muss natürlich autorisiert werden.

.bootimage/boot-cd Authentifizierungsmaske
image::boot-cd-authent.png["Screenshot: bootimage/boot-cd Authentifizierungsmaske",width=400]

Sie erhalten daher eine Loginmaske, bei der Sie sich als ein Mitglied der Gruppe {opsi-admin-group} authentifizieren müssen. Wenn dies Erfolgreich war, so teilt der Client dem Server seine Daten mit und der Client wird auf der Serverseite automatisch erstellt. Als nächstes fragt der Client die Liste der verfügbaren netboot Produkte ab und stellt Sie Ihnen zur Auswahl zur Verfügung.

.bootimage/boot-cd netboot Produktauswahl
image::boot-cd-product.png["Screenshot: bootimage/boot-cd netboot Produktauswahl",width=200]

Sie können jetzt direkt das zu installierende Betriebssystem (oder z.B. hwinvent) auswählen.

[[opsi-getting-started-firststeps-osinstall-fill-base-packages]]
=== Betriebssysteminstallation: Vervollständigen der Basispakete für Windows

In den zum Download empfohlenen Paketen sind lediglich Basispakete (Framework) enthalten. Diese dienen zur Installation der Windows-Betriebssysteme, müssen jedoch noch vervollständigt werden, da sie nicht die Dateien zur Installation des Betriebssystems selbst enthalten.

Zur automatischen Windows-Betriebssysteminstallation müssen Sie Ihre vorhandenen Original-Windows-Installationsdateien kopieren (und ggf und den Windows-Lizenzschlüssel auf dem Server ablegen).


[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6]]
=== NT6 Familie: ab Win7 / 2008R2

Um diese Betriebssysteme installieren zu können, wird ein sogenanntes WinPE als 'Live-System' genutzt. Sie können es mit Hilfe eines opsi - Paketes erstellen (+opsi-winpe+), oder von Hand, wenn Sie möchten.
Grundsätzlich ist die Windows-Version des PE unabhängig von der zu installierenden Windows-Version. Wichtig ist vor allem die Verfügbarkeit von Festplatten- und Netzwerkkarten - Treibern an dieser Stelle.
Microsoft empfiehlt für 32-Bit Installationen ein 32-Bit PE, bzw. für 64-Bit ein 64-Bit PE.

'"Um eine 64-Bit-Version von Windows zu installieren, müssen Sie eine 64-Bit-Version von Windows PE verwenden. Um eine 32-Bit-Version von Windows zu installieren, müssen Sie eine 32-Bit-Version von Windows PE verwenden."' +
http://technet.microsoft.com/de-de/library/cc766093.aspx

In jedem Fall benötigen Sie ein "Assessment and Deployment Kit" (ADK, Win8.1 bzw 10), bzw dessen Vorgänger "Windows Automated Installation Kit" (Windows AIK; bis Windows 7), welches Sie auf ein unterstütztes Windows Betriebssystem (bevorzugt 64 Bit) installieren.: +

* link:https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install[Windows 10 / 8.1 ADK]

Installieren Sie das Windows PE Add-On für ADK (nach Möglichkeit auf einer 64Bit- Maschine) in den vorgeschlagenen Pfad unter `Program Files (x86)`. Wählen Sie nur die "Windows-Vorinstallationsumgebung (Windows PE)" aus; Abhängigkeiten werden automatisch ausgewählt. +

* link:http://www.microsoft.com/downloads/details.aspx?familyid=696DD665-9F76-4177-A811-39C26D3B3B34&displaylang=de[WAIK Windows 7]

Sie können das ISO brennen oder mounten und dann installieren.


[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-pe]]
==== Erstellen eines PE

Die einfachste Methode setzt voraus, dass Sie bereits einen Windows-Computer haben, auf dem sowohl der opsi-client-agent installiert ist, als auch das Windows ADK (Win8.1, Win10).
Der manuelle Weg wird anschließend unter <<opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-pe-manual>> beschrieben.

[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-pe-opsi]]
===== Automatisiertes Erstellen eines PE mit opsi

* Setzen Sie das Localboot-Produkt `opsi-winpe` für diesen Client auf `once`, wählen Sie ggf. in den Produkt-Properties rechts unten `x86` statt `x64` aus, und speichern Sie (Rechtsklick > Speichern)
* (sofern das opsi-Produkt `opsi-winpe` nicht vorhanden ist, installieren Sie es auf dem opsi - Server mittels `opsi-package-updater -v install opsi-winpe`)
* veranlassen Sie ein Installations - Event für diesen Client (zB Rechtsklick > _on-demand_, oder Reboot)
* Nach erfolgreichem Lauf dieser Aktion verschieben oder kopieren Sie den Inhalt des entstandenen Verzeichnisses  auf dem Client `C:\winpe_<ARCH>\media\` in das bereits existente Verzeichnis des zu installierenden Betriebssystems `\\opsiserver\opsi_depot_rw\<Betriebssystem>\winpe\`
* Führen Sie nun zuletzt folgenden Kommandozeilen - Befehl  auf dem neuen opsi-Server aus. Fertig.
[source,prompt]
----
opsi-set-rights
----


[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-pe-manual]]
===== Manuelles Erstellen eines PE für Windows 10 & Windows 8 (ADK)

Die Befehle für 32- und 64-Bit sind nahezu identisch, nur müssen die Einträge *<ARCH>* mit entweder *x86* , *amd64* oder *ia64* ersetzt werden.

Führen Sie Start => Programme => Windows Kits => Windows ADK => "Umgebung für Bereitstellungs- und Imageerstellungstools" aus; eine Eingabe-Aufforderung erscheint (in dieser sind in der Folge benötigte Umgebungsvariablen gesetzt)

* WinPE kopieren:
[source,prompt]
----
copype.cmd <ARCH> C:\winpe
----

* Image mounten/einhängen: +
[source,prompt]
----
dism /Mount-Wim /WimFile:C:\winpe\media\sources\boot.wim /index:1 /MountDir:c:\winpe\mount
----

* Startnet.cmd ersetzen:
[source,prompt]
----
echo c:\opsi\startnet.cmd > "C:\winpe\mount\Windows\System32\startnet.cmd"
----
(Hinweis: `c:\opsi\startnet.cmd` wird vom opsi-linuxbootimage in der `setup.py` erstellt nebst dem oben entfernten wpeinit-Aufruf).

* Image wieder aushängen:
[source,prompt]
----
dism /Unmount-Wim /MountDir:c:\winpe\mount /Commit
----

* Den Inhalt von `C:\winpe\ISO` nach `/var/lib/opsi/depot/<productid>/winpe` kopieren. +
Rechte anpassen (z.B.):
[source,prompt]
----
opsi-setup --set-rights /var/lib/opsi/depot/<productid>/winpe
----


===== Manuelles Erstellen eines PE für Windows 7 (WAIK)

Die Befehle für 32- und 64-Bit sind nahezu identisch, nur müssen die Einträge *<ARCH>* mit entweder *x86* , *amd64* oder *ia64* ersetzt werden.

Alles als Administrator aus der Eingabeaufforderung mit erweiterten Rechten ausführen (Start => Programme => Zubehör =>mit rechter Maustaste auf "Eingabeaufforderung" => Ausführen als ... => Administrator)

* WinPE kopieren:
[source,prompt]
----
"%ProgramFiles%\Windows AIK\Tools\PETools\copype.cmd" <ARCH> C:\winpe
----

* Image mounten/einhängen: +
[source,prompt]
----
"%ProgramFiles%\Windows AIK\Tools\<ARCH>\imagex.exe" /mountrw "C:\winpe\winpe.wim" 1 "C:\winpe\mount"
----

* Startnet.cmd ersetzen:
[source,prompt]
----
echo c:\opsi\startnet.cmd > "C:\winpe\mount\Windows\System32\startnet.cmd"
----
(Hinweis: `c:\opsi\startnet.cmd` wird vom opsi-linuxbootimage in der `setup.py` erstellt nebst dem oben entfernten wpeinit-Aufruf).

* Image wieder aushängen:
[source,prompt]
----
"%ProgramFiles%\Windows AIK\Tools\<ARCH>\imagex.exe" /commit /unmount "C:\winpe\mount"
----

* Verschieben des fertigen WinPE (von dort werden mehrere Files auf den Server verschoben).
[source,prompt]
----
move "C:\winpe\winpe.wim" "C:\winpe\ISO\sources\boot.wim"
----

* Den Inhalt von `C:\winpe\media`  nach `/var/lib/opsi/depot/<productid>/winpe` kopieren. +
Rechte anpassen (z.B.):
[source,prompt]
----
opsi-setup --set-rights /var/lib/opsi/depot/<productid>/winpe
----

[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-extendpe]]
==== Erweiterung eines PE

Manchmal ist es sehr nützlich, das Windows PE zu erweitern. Besonders bei Dell-Hardware gibt es spezielle Netzwerk- und Storage-Treiber, die speziell für den PE-Einsatz empfohlen werden. Folgende Anleitung beschreibt, wie man ein PE mit Treibern erweitern kann. Diese Anleitung funktioniert nur mit Windows 7. (Windows Vista beinhaltet nicht das benötige dism - Deployment Image Servicing and Management.)  Weiterhin setzt diese Anleitung vorraus, dass die Schritte im vorigen Kapitel zum erstellen des PE ausgeführt wurden.

NOTE: Windows Automated Installation Kit wird für folgende Schritte nicht benötigt.

Herunterladen von Dell-PE-Treibersammlung. Bitte beachten, dass für Windows 7 die WINPE 3.0 Treiber benötigt werden. Die heruntergeladene CAB-Datei muss nun lokal ausgepackt werden. Dies kann man mit 7zip oder aber mit dem Kommandozeilentool expand erledigen. Für die Übersichtlichkeit wird empfohlen ein Verzeichnis wie zum Beispiel dell-driver auf C: an zu legen und die CAB-Datei dort aus zu packen.

* Nun wird zunächst das Image untersucht. Als Administrator die Eingabeaufforderung starten (Start => Programme => Zubehör =>mit rechter Maustaste auf "Eingabeaufforderung" => Ausführen als ... => Administrator) und folgenden Befehl eingeben:
[source,prompt]
----
dism /Get-WimInfo /WimFile:C:\winpe\ISO\sources\boot.wim
----

Aus der Ausgabe des Befehls braucht man für den nächsten Schritt den Index. Da in der Regel ein winpe aus einem einzigen Image besteht, sollte in der Regel der Index 1 immer funktioneren.

* Mit folgendem Befehl wird das Image gemountet:
[source,prompt]
----
dism /Mount-Wim /WimFile:C:\winpe\ISO\sources\boot.wim /index:1 /MountDir:c:\winpe\mount
----

* Nun wird das PE mit den dafür ausgepackten Treibern erweitert:
[source,prompt]
----
dism /Image:C:\winpe\mount  /Add-Driver /Driver:c:\dell-driver\winpe\x64 /Recurse
----

Für 32-Bit muss das `x64` durch `x86` ersetzt werden. Die Driver-CAB von Dell beinhaltet die Treiber für beide Architekturen.

NOTE: Wenn man nur einen Treiber integrieren möchte, kann man die Option `/Recurse` weglassen und statt ein Verzeichniss direkt die inf-Datei des Treibers angeben. Weiterhin ist es möglich mit dem Parameter `/ForceUnsigned` auch nicht signierte Treiber in ein PE zu integrieren.

* Zum Schluss wird das Image wieder ausgehängt und die Änderungen übernommen:
[source,prompt]
----
dism /Unmount-Wim /MountDir:c:\winpe\mount /Commit
----

* Das Verzeichnis `C:\winpe\ISO` als Verzeichnis `winpe` nach `/var/lib/opsi/depot/win7/` bzw. `/var/lib/opsi/depot/win2008` kopieren. +
Rechte anpassen (z.B.):
[source,prompt]
----
opsi-set-rights /var/lib/opsi/depot/win7/winpe
----


[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-unattend]]
==== unattend.xml

Die Steuerdatei für die unattended Installation ist die `unattend.xml`, welche unter `/var/lib/opsi/depot/win7/custom` zu finden ist.
Mögliche Modifikationen an dieser Datei sollten in diesem Verzeichnis und nicht im opsi Verzeichnis gemacht werden.

Die von uns mitgelieferte `unattend.xml` enthält Verweise auf die Netboot-Produkteigenschaften, welche unter anderem für die Aktivierung des Administrator Accounts mit dem Passwort 'nt123' sorgen.

Dokumente zur Unattend.xml finden sich nach Installation des WAIK in
`c:\Program Files\Windows\Waik\docs\chms`

[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-drivers]]
==== Treiber-Integration

Die Treiber-Integration verläuft analog {client-os}: Die Treiber werden unter `/var/lib/opsi/depot/<product-id>/drivers/drivers` abgelegt.
Danach wird im Ordner `/var/lib/opsi/depot/<product-id>/` das Script `./create_driver_links.py` aufgerufen.

Zu beachten ist, dass nur signierte Treiber verwendet werden können.
Bei der Verwendung von Treiber-Paketen wie z.B. von driverpacks.net ist darauf zu achten, dass Sie die Pakete für {client-os} verwenden.

[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-installfiles]]
==== Bereitstellung der Installationsmedien

Kopieren der Installations-DVD nach +
`/var/lib/opsi/depot/<productid>/installfiles`
und passen Sie Rechte/Eigentümer an:

[source,prompt]
----
opsi-set-rights /var/lib/opsi/depot/<productid>/installfiles
----

[[opsi-getting-started-firststeps-osinstall-fill-base-packages-nt6-logfiles]]
==== Log-Dateien der unattended-Installation

* `c:\Windows\Panther\setupact.log`: +
Log bis Ende Setup-Phase 4 (läuft unter WinPE)

* `c:\Windows\Panther\setupact.err`: +
Fehler-Log bis Ende Setup-Phase 4 (läuft unter WinPE)

* `c:\Windows\Panther\UnattendGC\setupact.log`: +
Log ab Specialize-Phase

* `c:\Windows\Panther\UnattendGC\setupact.err`: +
Fehler-Log ab Specialize-Phase

* `c:\Windows\System32\Winevt\Logs\*`

* `c:\Windows\ntbtlog.txt` (nur nach aktivierter Startprotokollierung)

[[opsi-getting-started-firststeps-osinstall-productkey]]
=== Windows-Produktschlüssel

Wenn Sie über das Modul opsi-Lizenzmanagement verfügen, können Sie die Windows Lizenzschlüssel über das Lizenzmanagement Modul verwalten. Lesen Sie dazu das Lizenzmanagement Handbuch bzw. das entsprechende Kapitel im opsi-Handbuch.

Haben Sie kein Lizenzmanagement oder wollen dieses nicht verwenden, gehen Sie wie folgt vor.

Wenn Sie bereits opsi-Clients eingerichtet haben, können Sie im opsi-Konfigurationseditor einen Windows-Produktschlüssel per Client eintragen:

* einen Client auswählen
* zum Tab Netboot-Produkte wechseln
* dort zB das Produkt {opsi-client-os} auswählen
* rechts in der Schalter-Liste in die Property-Zeile productkey gehen
* in das Value-Feld den Schlüssel eintragen
* das Feld verlassen, die Änderungen speichern.

Oder Sie arbeiten auf der Kommandozeile. Mit Angabe eines opsiservers: '<opsiserver.domain.local>' werden gemeinsame Werte für alle Clients am Depot abgefragt/gesetzt:

Die vorgegebenen Werte der Produkt-Properties erfahren Sie mit
(passen Sie gegebenfalls das angegebene Produkt an und tauschen Sie '<opsiserver.domain.local>' mit der FQDN Ihres opsiservers aus):
[source,prompt]
----
opsi-admin -d method productPropertyState_getObjects [] '{"productId":"win10-x64","objectId":"opsiserver.domain.local"}'
----

Um die Vorgabewerte abzuändern können Sie wie folgt vorgehen: Lesen Sie die Daten aus und schreiben Sie das Ergebnis in eine Datei. Diese kann nun verändert und das Ergebnis zurückgeschrieben werden.

Auslesen und wegschreiben (passen Sie ggf. das angegebene Produkt an und tauschen Sie '<opsiserver.domain.local>' mit der FQDN Ihres opsiservers aus):
[source,prompt]
----
opsi-admin -d method productPropertyState_getObjects [] '{"productId":"win10-x64","objectId":"opsiserver.domain.local"}' > /tmp/property_config.json
----

Editieren Sie die entstandene Datei `/tmp/property_config.json` und ändern dabei die Einträge für '"values"' der gewünschten Properties. Die veränderte Datei lesen Sie wieder ein mit dem Befehl:

[source,prompt]
----
opsi-admin -d method productPropertyState_updateObjects < /tmp/property_config.json
----

Kontrollieren Sie das Ergebnis mit einem Aufruf von (passen Sie ggf. das angegebene Produkt an und modifizieren Sie '<opsiserver.domain.local>' mit der FQDN Ihres opsiservers):
[source,prompt]
----
opsi-admin -d method productPropertyState_getObjects [] '{"productId":"win10-x64","objectId":"opsiserver.domain.local"}'
----


[[opsi-getting-started-firststeps-osinstall-start]]
=== Start der Windows-Installation

Zum Starten einer Windows-Installation wählen Sie nun im {opsi-configed} den betreffenden Client aus, setzen unter dem Karteireiter 'Netboot-Produkte' für die gewünschten Betriebssystem (z.B. {opsi-client-os}) die Aktion auf 'setup' und klicken auf den roten Haken (der wieder grün wird).

Der Client sollte jetzt beim Booten ein Linux Bootimage übers Netz ziehen, in dem Sie nochmal die PC-Neu-Installation bestätigen müssen. Dann sollte alles automatisch weiter laufen, bis schließlich die Logon-Aufforderung des installierten Windows auf dem Bildschirm steht.

NOTE: Sollte nach dem Laden des Bootimages der Bildschirm schwarz bleiben oder die Netzwerkkarte nicht (korrekt) funktionieren, so muss für diese konkrete Hardware evtl. die Startparameter des Bootimages angepasst werden. +
Dies können Sie im '{opsi-configed}' im Tab 'Hostparameter' am Eintrag 'opsi-linux-bootimage.append' tun. Details hierzu finden Sie im opsi-manual im Kapitel 'Netboot Produkte'.

CAUTION: Vorsicht bei Clients mit einer über 2TB großen Festplatte. In einem nicht UEFI-System beträgt die maximale Partitionsgröße 2 Terabyte. Sofern eine größere Partition angelegt werden soll schlägt die Installation fehl. Dies ist technisch durch die standard Partitionstabelle bedingt. Sie müssen die Festplatte in zwei Partitionen aufteilen. Dies können Sie über die Product-Properties steuern. Oder Sie erwerben das UEFI-Modul, wodurch diese technische Limietierung entfällt.

[[opsi-getting-started-firststeps-osinstall-structure]]
=== Aufbau der Produkte zur unattended Installation

Diese Kapitel betrifft die Windows-Netboot-Produkte.

[[opsi-getting-started-firststeps-osinstall-structure-dirs]]
==== Übersicht des Verzeichnisbaums

[source,configfile]
----
<productid>-
           |-i386/				NT5 only: Installations files
           |-installfiles/		        NT6 only: Installations files
           |-winpe/				NT6 only
           |-opsi/				Scripte und Templates by opsi.org
           |  |-$oem$/					NT5 only: $oem$ gemaess MS
           |  |-postinst.d/				Scripte nach OS-Install by opsi.org
           |  !-unattend.(txt/xml).template		Template by opsi.org
           |-custom/				Scripte und Templates by customer
           |  |-$oem$/					NT5 only: $oem$ gemaess MS by customer
           |  |-postinst.d/				Scripte nach OS-Install by customer
           |  !-unattend.(txt/xml)			unattend.txt by customer
           |-drivers/				drivers Verzeichnis
        user   |  |-drivers/			drivers Verzeichnis
           |  |-pciids/				Symlinkbaum zu Treibern
           |  |-vendors/			Symlinkbaum zu Treibern
           |  |-classes/			Symlinkbaum zu Treibern
           |  |-usbids/				Symlinkbaum zu Treibern
           |  |-hdaudioids/			Symlinkbaum zu Treibern
           |  |-pci.ids				PCI-IDs DB
           |  !-usb.ids				USB-IDs DB
           |-setup.py				Installationsscript
           |-<productid>_<version>.control	Meta Daten (nur zur Info)
           |-<productid>.files			Dateiliste (automatisch erstellt)
           |-create_driver_links.py		Script zur Treiberverwaltung
           |-show_drivers.py			Script zur Treiberverwaltung
           !-extract_driver_pack.py		Script zur Treiberverwaltung
----

[[opsi-getting-started-firststeps-osinstall-structure-files]]
==== Die Dateien

* `setup.py` +
Dies ist das Installationsskript, welches vom Bootimage ausgeführt wird.
* `<productid>_<version>.control` +
enthält die Metadaten des Produkts, so wie sie vom Paketierer bereitgestellt wurden. Die Datei liegt hier nur zu Informationszwecken, d.h. Änderungen an dieser Datei haben keinerlei Auswirkungen auf das System.

* `<productid>.files` +
Diese Datei wird automatisch erzeugt und sollte nicht verändert werden.

* `create_driver_links.py` +
`show_drivers.py` +
`extract_driver_pack.py` +
Dies sind Scripte zur Treiberintegration, die im Kapitel <<opsi-getting-started-firststeps-osinstall-driverintegration,Vereinfachte Treiberintegration in die automatische Windowsinstallation>>, näher erläutert werden.

[[opsi-getting-started-firststeps-osinstall-structure-i386]]
==== Verzeichnis installfiles / winpe

* `installfiles` +
Enthält den Inhalt der Installations-CD.

* `winpe` +
Enthält ein bootbares winpe Image.

[[opsi-getting-started-firststeps-osinstall-structure-opsicustom]]
==== Verzeichnisse opsi / custom

Diese beiden Verzeichnisse enthalten Scripte und Konfigurationsdateien zur Steuerung der Betriebssysteminstallation. Während der Installation wirken diese Verzeichnisse zusammen, indem die Dateien aus custom Vorrang haben.

Das Verzeichnis opsi enthält Dateien, die mit Updates jederzeit überspielt werden können. Hier sollten also keine Änderungen vorgenommen werden. Für Anpassungen können Sie Änderungen im Verzeichnis custom vornehmen, welches bei Updates nicht überspielt wird.

Das Unterverzeichnis `postinst.d` enthält Scripte, welche nach der eigentlichen Installation des Betriebssystems über die `postinst.cmd` gestartet werden, um z.B. den opsi-client-agent zu installieren. Die Scripte werden dabei in alphabetischer Reihenfolge abgearbeitet. Um die Reihenfolge zu verdeutlichen, fangen die Dateinamen mit einer zweistelligen Nummer an (`10_dhcp.cmd`). Wollen Sie hier Erweiterungen vornehmen, so können Sie im Verzeichnis custom/postinst.d Scripte mit Nummern zwischen den vollen 10ern ablegen (`13_myscript.cmd`). Die vollen 10er sind für die Pflege durch opsi.org/uib reserviert. Das Script `99_cleanup.cmd` ist das letzte und endet mit einem Reboot.

[[opsi-getting-started-firststeps-osinstall-structure-drivers]]
==== Verzeichnis drivers

Dieses Verzeichnis dient der Treiberintegration und ist im folgenden Kapitel beschrieben.

[[opsi-getting-started-firststeps-osinstall-driverintegration]]
=== Vereinfachte Treiberintegration in die automatische Windowsinstallation

Administriert man einen Pool von PCs, die Geräte besitzen, deren Treiber nicht in der Windows-Standardinstallation enthalten sind, so ist es meist sinnvoll, diese Treiber direkt in die Installation zu integrieren. Bei Netzwerkgeräten kann dies teilweise sogar unumgänglich sein, denn ein startendes Windows ohne Netzwerkkarte ist für den Administrator nicht ohne weiteres erreichbar.

Opsi unterstützt Sie durch eine Automatisierung der Treibereinbindung und vereinfacht so die Bereitstellung der Treiber. Dabei müssen die Treiber nur in dem korrekten Verzeichnis abgelegt werden. Durch den Aufruf eines Scripts werden dann die Treiberverzeichnisse durchsucht und ein Katalog erstellt, anhand dessen das Bootimage automatisch die richtigen Treiber erkennen und einbinden kann. Dabei können sowohl Standard-Treiber, USB-Treiber, HD-Audio-Treiber wie auch Treiber für Festplattencontroller (Textmode Treiber) abgelegt und automatisch eingebunden werden.

Damit die Treiber sofort bei der Windowsinstallation mit installiert werden, müssen Sie in einer bestimmten Form auf dem Server hinterlegt werden. Hierzu sind Treiberverzeichnisse geeignet, die eine '\*.inf'-Datei enthalten, die den Treiber für das Windows-Setupprogramm beschreibt. Irgendwelche in `setup.exe`, '*.zip' oder anders verpackten Treiber sind hier unbrauchbar. Mit dem Programm 'double driver' (http://www.boozet.org/dd.htm) können Sie von einem installierten Rechner die Treiber im geeigneten Format extrahieren.

Es stehen mehrere Ebenen zur Bereitstellung von Treibern zur Verfügung:

* Allgemeine Treiber Pakete

* Treiber die zu Ihrer Hardware gehören aber nicht speziell zu geordnet sind

* Treiber die manuell Rechnern zu geordnet sind

* Treiber die über die Felder <vendor>/<model> der Inventarisierung automatisch den Rechnern zu geordnet werden.

Wie diese unterschiedlichen Ebenen verwendet werden können ist im folgenden beschrieben:

[[opsi-getting-started-firststeps-osinstall-driverintegration-generaldrivers]]
==== Allgemeine Treiber Pakete

Wenn die Hardwareausstattung sehr heterogen ist, kann es sinnvoll sein mit allgemeinen Treiberpaketen zu arbeiten. +
Allgemeine Treiber legen Sie ab unter `./drivers/drivers`. +
Solche allg. Treiber Pakete finden Sie http://driverpacks.net/ . +
Laden Sie die gewünschten Treiber Pakete in ein temporäres Verzeichnis herunter und entpacken die Treiberpakete mit:
[source,prompt]
----
./extract_driver_pack.py <pfad zu dem temporären Verzeichnis mit den komprimierten driverpacks>
----
Hiermit werden die Treiber entpackt und in das Verzeichnis `./drivers/drivers/` abgelegt. +
Nachteil dieser Pakete ist, das sich hier auch Treiber finden welche zwar von der Beschreibung zu Ihrer Hardware passen aber nicht unbedingt mit Ihrer Hardware funktionieren. +
Treiber welche im Verzeichnis `./drivers/drivers/` liegen, werden anhand der PCI-Kennungen (bzw. USB- oder HD_Audio-Kennung) in der Beschreibungsdatei des Treibers als zur Hardware passend erkannt und in das Windows Setup mit eingebunden.

[[opsi-getting-started-firststeps-osinstall-driverintegration-preferred]]
==== Treiber die zu Ihrer Hardware gehören aber nicht speziell zu geordnet sind

Haben Sie nur wenige unterschiedliche Hardware zu unterstützen, so können Sie die Treiber bei den Herstellern suchen. +
Zusätzliche bzw. geprüfte Treiber gehören in jeweils eigene Verzeichnisse (Name und Tiefe der Verzeichnisstruktur egal) unterhalb des Verzeichnisses +
`./drivers/drivers/preferred`. +
Treiber welche im Verzeichnis `./drivers/drivers/preferred` liegen,
werden gegenüber den Treibern in `./drivers/drivers/` bevorzugt anhand der PCI-Kennungen (bzw. USB- oder HD_Audio-Kennung) in der Beschreibungsdatei des Treibers als zur Hardware passend erkannt und in das Windows Setup mit eingebunden. +
Finden sich z.B. zu eine PCI-ID in unterschiedlichen Treiber unter `preferred`, so kann dies zu Problemen bei der Treiber Zuordnung führen. In diesem Fall ist eine direkte Zuordnung der Treiber zu dem Client notwendig.

[[opsi-getting-started-firststeps-osinstall-driverintegration-additional]]
==== Treiber die manuell Rechnern zu geordnet sind

Zusätzliche Treiber, die unabhängig von ihrer Zuordnung bzw. Erkennung über die PCI- oder USB-IDs installiert werden sollen, gehören in jeweils eigene Verzeichnisse (Name und Tiefe der Verzeichnisstruktur egal) unterhalb des Verzeichnisses `./drivers/drivers/additional`. Über das Produkt-Property 'additional_drivers' können Sie einen oder mehrere Pfade von Treiberverzeichnissen innerhalb von `./drivers/drivers/additional` einem Client zu ordnen. Im Produkt-Property 'additional_drivers' angegebene Verzeichnisse werden rekursiv durchsucht und alle enthaltenen Treiber eingebunden. Dabei wird auch symbolischen Links gefolgt. Dies können Sie nutzen, um für bestimmte Rechner-Typen ein Verzeichnis zu erstellen (z.B. dell-optiplex-815).

Wird in den über 'additional_drivers' angegebenen Treiberverzeichnissen ein Treiber für ein vorhandenes PCI-Gerät (oder HD-Audio, USB) gefunden, so wird für dieses Gerät kein weiterer Treiber aus `drivers/preferred/` oder `drivers/` mehr eingebunden ('additional_drivers' ist sozusagen 'super-preferred'). Damit hat 'additional_drivers' die Funktion Treiber hinzuzufügen, welche über die normale Treibererkennung nicht gefunden würden.

[[opsi-getting-started-firststeps-osinstall-driverintegration-byaudit]]
==== Treiber die über die Felder <vendor>/<model> der Inventarisierung automatisch den Rechnern zu geordnet werden.

Der im vorigen Abschnitt beschriebene Mechanismus der direkten Zuordnung von Treibern zu Geräten, kann seit dem 2 Teil des Service Release opsi 4.0.2 automatisiert werden. Dazu wird in dem Verzeichnis `./drivers/drivers/additional/byAudit` nach einem Verzeichnisnamen gesucht der dem bei der Hardwareinventarisierung gefundenen 'Vendor' entspricht. In diesem 'Vendor' Verzeichnis wird nun nach einem Verzeichnisnamen gesucht, das dem bei der Hardwareinventarisierung gefundenen 'Model' entspricht. Wird ein solches Verzeichnis gefunden, so wird dieses Verzeichnis genauso behandelt, als wäre es über das Produkt-Property 'additional_drivers' manuell zugewiesen.

Dabei können seit opsi 4.0.5 die Treiber für einen {opsi-client} über den {opsi-configed} im Reiter Hardwareinventarisiering bereitgestellt werden (vgl.:opsi-Handbuch Automatisierte Treiberintegration).

Die Abarbeitung im {opsi-linux-bootimage} erfolgt in der Reihenfolge

* `<vendor>/<model> (<sku>)`
* ohne Fund greift der Fallback auf `<vendor>/<model>`
* ohne Fund greift der Fallback auf die Hauptplatine `<vendor>/<motherboard-model>`.

Einige Hersteller verwenden Modellbezeichnungen, die für diese Methode sehr ungünstig sind, da man einige Sonderzeichen wie / nicht in Datei- oder Verzeichnisnamen verwenden darf. Ein Beispiel dafür wäre als Modelbezeichnung: "5000/6000/7000". Ein Verzeichnis mit dieser Bezeichnung ist wegen den Sonderzeichen nicht gestattet. Seit der dritten Service Release opsi 4.0.3 werden deshalb folgende Sonderzeichen: < > ? " : | \ / * intern durch ein _ ersetzt. Mit dieser Änderung kann man oben genanntes schlechtes Beispiel als: "5000_6000_7000" anlegen und das Verzeichnis wird automatisch zu gewiesen, obwohl die Information in der Hardwareinventarisierung nicht der Verzeichnisstruktur enstprechen.

[[opsi-getting-started-firststeps-osinstall-driverintegration-structure]]
==== Struktur des Treiber Verzeichnisses und Ablage der Treiber:

[source,configfile]
----
/var/
  !-lib/
     !-opsi/depot/
        !-<productid>/
           !-drivers
              |-classes/		(Links auf Treiber über Geräteklassen)
              |-hdaudioids/		(Links auf HD-Audio Treiber)
              |-pciids/			(Links auf Treiber über PCI-Kennung)
              |-pci.ids			(PCI Datenbank)
              |-usbids/			(Links auf Treiber über USB-Kennung)
              |-usb.ids			(USB Datenbank)
              |-vendors/		(Links auf Treiber über Hersteller)
              !-drivers			(Platz für allg. Treiber Packs)
                 |-additional/		(Für manuell zugeordnete Treiber)
                    |-byAudit/		Modell spezifische Treiber welche
                       |-<vendor>		über die Hardwareinventarisierung
                          |-<model>		zugeordnet werden
                 |-buildin/		(Daten aus dem i386 Baum)
                 |-preferred/		(geprüfte Treiber)
                 |-exclude/		(ausgeschlossene Treiber)
                 !-mydriverpacks/	(Beispiel Treiber Pack)
----

[[opsi-getting-started-firststeps-osinstall-driverintegration-processing]]
==== Abarbeitung der unterschiedlichen Ebenen der Treiberintegration

Als oberste Priorität werden alle Treiber eingebunden, welche über das Property 'additional_drivers' bzw. die über die Inventarisierungsdaten in `./drivers/drivers/additional/byAudit` gefunden werden. Im Rahmen der Einbindung von Treibern wird geprüft für welche der Hardware eines Geräts (anhand der PCI-,USB-,HDAudio-Kennungen) hierdurch ein Treiber bereit gestellt wurde. Nur für Geräte für die auf diese Weise noch kein Treiber bereitgestellt wurde wird über die nachfolgenden Methoden ein Treiber gesucht.

Für Geräte denen nicht über 'additional_drivers' (bzw. 'byAudit') ein Treiber zu geordnet wurde wird anhand der PCI Kennung (bzw. USB-, HDAudio-Kennung) ein passender Treiber gesucht und eingebunden.

'Einbindung' von Treiber bedeutet dabei:

* Der Treiber wird auf die lokale Festplatte nach `c:\drv\<num>` kopiert.

* Dem Windows Setup wird in der unattended Datei mitgeteilt, in den Verzeichnissen unterhalb von `c:\drv\` nach passenden Treibern zu suchen.

[[opsi-getting-started-firststeps-osinstall-driverintegration-drivercheck]]
==== Treiber hinzufügen und prüfen

Nach jedem Hinzufügen eines Treibers oder jeden anderen Änderung im `./drivers/drivers` Verzeichnis (oder darunter) rufen Sie im Stammverzeichnis des netboot Produktes Verzeichnis folgenden Befehl auf, um die Rechte korrekt zu setzen:
[source,prompt]
----
opsi-set-rights ./drivers
----

Danach rufen Sie das Script `./create_driver_links.py` auf. Dieses durchsucht die Verzeichnisse unterhalb von './drivers/drivers' und erzeugt eine Reihe von Links anhand deren die Zuordnung der Treiber zu bestimmter Hardware (PCI-IDs, USB-IDs, HD-Audio-IDs) zu erkennen ist. Die Treiber aus dem preferred Verzeichnis werden von dem Script bevorzugt verwendet.

Das `setup.py` Script des Bootimages untersucht die Hardware des zu installierenden Computers und identifiziert die notwendigen Treiber. Diese werden dann auf die Festplatte kopiert und die unattend.xml entsprechend gepatcht. Das Script `create_driver_links.py` durchsucht auch bei NT5 Produkten einmalig den 'i386' Baum und extrahiert die Inf-Dateien der von Windows mitgelieferten Treiber nach 'windows_builtin'. Sollten Sie am i386-Baum eine Änderung vornehmen (z.B. durch das Einspielen eines Servicepacks) so löschen Sie dieses Verzeichnis und führen `create_driver_links.py` erneut aus. Bei NT6 Produkten werden die Treiber welche sich im WinPE finden als 'windows_builtin' erkannt.

Liegt zu einem Client eine Hardware-Inventarisierung vor, so kann über den Befehl:
[source,prompt]
----
./show_drivers.py <clientname>
----
ausgegeben werden, welche Treiber das Bootimage via PCI-IDs, USB-IDs, HD-Audio-IDs und 'additional_drivers' (bzw. 'byAudit') zur Installation auswählen würde und zu welcher Hardware noch kein Treiber bereit steht.

Kontrollieren Sie die Ausgabe von `show_drivers.py` um zu prüfen ob die gewünschten Treiber eingebunden werden.

Es kann vorkommen, das Treiberverzeichnisse von Herstellern Treiber für unterschiedliche Betriebssystemversionen ( z.B. {client-os}) oder Konfigurationen (SATA / SATA-Raid) enthalten. Das `create_driver_links.py` script kann das nicht unterscheiden. Wenn Sie die Vermutung haben, das ein verlinkter Treiber falsch ist, so verschieben Sie diesen Treiber in das Verzeichnis `drivers/exclude` und führen `create_driver_links.py` erneut aus. Treiber die in
`drivers/exclude` liegen werden bei der Treiberintegration nicht berücksichtigt.

Beispiel einer `show_drivers.py` Ausgabe für einen Client:

[source,prompt]
----
./show_drivers.py pcdummy

PCI-Devices
   [(Standardsystemgeräte), PCI Standard-PCI-zu-PCI-Brücke]
      No driver - device directory  /var/lib/opsi/depot/<productid>/drivers/pciids/1022/9602 not found
   [ATI Technologies Inc., Rage Fury Pro (Microsoft Corporation)]
      Using build-in windows driver
   [(Standard-IDE-ATA/ATAPI-Controller), Standard-Zweikanal-PCI-IDE-Controller]
      /var/lib/opsi/depot/<productid>/drivers/drivers/D/M/N/123
   [Realtek Semiconductor Corp., Realtek RTL8168C(P)/8111C(P) PCI-E Gigabit Ethernet NIC]
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/realtek_gigabit_net_8111_8168b
   [IEEE 1394 OHCI-konformer Hostcontroller-Hersteller, OHCI-konformer IEEE 1394-Hostcontroller]
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/197B/2380' not found
   [Advanced Micro Devices, Inc., AMD AHCI Compatible RAID Controller]
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/ati_raid_sb7xx
   [(Standard-USB-Hostcontroller), Standard OpenHCD USB-Hostcontroller]
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/1002/4397' not found
   [ATI Technologies Inc, ATI SMBus]
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/ati_smbus

USB-Devices
   [(Standard-USB-Hostcontroller), USB-Verbundgerät]
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/brother_844x_pGerb
   [Microsoft, USB-Druckerunterstützung]
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/brother_844x_pGerb

Additional drivers
   [ati_hdaudio_azalia]
     /var/lib/opsi/depot/<productid>/drivers/drivers/additional/ati_hdaudio_azalia
----

Beispiel für einen Client mit 'additional_drivers':
[source,prompt]
----
 ./show_drivers.py e5800
Manually selected drivers (additional)
   [hp_e5800]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64/HDXHPAI3.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64/HDX861A.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64/HDXHPAI1.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64/HDXCPC.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64/HDXHPAI2.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/autorun.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/ibxHDMI/IntcDAud.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/HDMI/IntcHdmi.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/Graphics/kit24890.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/IIPS/Impcd.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp54284/Realtek 64bit/hp64win7.inf]

PCI-Devices
   [8086:27C8]  Intel : Intel(R) N10/ICH7 Family USB Universal Host Controller - 27C8
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27DA]  Intel : Intel(R) N10/ICH7 Family SMBus Controller - 27DA
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27C9]  Intel : Intel(R) N10/ICH7 Family USB Universal Host Controller - 27C9
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27DF]  Intel : Intel(R) ICH7 Family Ultra ATA Storage Controllers - 27DF
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27CA]  Intel : Intel(R) N10/ICH7 Family USB Universal Host Controller - 27CA
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:2E30]  Intel : Intel(R) 4 Series Chipset Processor to I/O Controller - 2E30
      /var/lib/opsi/depot/<productid>/drivers/drivers/not_preferred/x64/C/Intel/1
   [8086:27CB]  Intel : Intel(R) N10/ICH7 Family USB Universal Host Controller - 27CB
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:2E32]  Intel Corporation : Intel(R) G41 Express Chipset
      Manually selected [hp_e5800] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp50134/Graphics
   [8086:27CC]  Intel : Intel(R) N10/ICH7 Family USB2 Enhanced Host Controller - 27CC
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:244E]  Intel : Intel(R) 82801 PCI-Brücke - 244E
      Using build-in windows driver
      This driver will not be integrated, because same device already integrated in: '/var/lib/opsi/depot/<productid>n/drivers/drivers/not_preferred/x64/C/Intel/1/dmi_pci.inf'
   [8086:27D0]  Intel : Intel(R) N10/ICH7 Family PCI Express Root Port - 27D0
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27B8]  Intel : Intel(R) ICH7 Family LPC Interface Controller - 27B8
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27D2]  Intel : Intel(R) N10/ICH7 Family PCI Express Root Port - 27D2
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27C0]  Intel : Intel(R) N10/ICH7 Family Serial ATA Storage Controller - 27C0
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/R293337/WIN7
   [8086:27D8]  Microsoft : High Definition Audio-Controller
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/8086/27D8' not found
   [10EC:8136]  Realtek : Realtek RTL8102E/RTL8103E-Familie-PCI-E-Fast-Ethernet-NIC (NDIS 6.20)
      Manually selected [hp_e5800] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp54284/Realtek 64bit

USB-Devices
   [0461:0010]  (Standardsystemgeräte) : USB-Eingabegerät
      No driver - vendor directory '/var/lib/opsi/depot/<productid>/drivers/usbids/0461' not found
   [0461:4D20]  (Standardsystemgeräte) : USB-Eingabegerät
      No driver - vendor directory '/var/lib/opsi/depot/<productid>/drivers/usbids/0461' not found
   [058F:6366]  Kompatibles USB-Speichergerät : USB-Massenspeichergerät
      No driver - vendor directory '/var/lib/opsi/depot/<productid>/drivers/usbids/058F' not found
   [0461:0010]  (Standard-USB-Hostcontroller) : USB-Verbundgerät
      No driver - vendor directory '/var/lib/opsi/depot/<productid>/drivers/usbids/0461' not found

HD-Audio-Devices
   [10EC:0662]  Realtek High Definition Audio
      Manually selected [hp_e5800] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/hp_e5800/sp52852/Vista64
----

Beispiel für einen Client mit 'byAudit':
[source,prompt]
----
 ./show_drivers.py pctry5detlef
Manually selected drivers (additional)
   [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series Secondary (Microsoft Corporation - WDDM)/atiilhag.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series (Microsoft Corporation - WDDM)/atiilhag.inf]
      [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/MEDIA/Realtek AC'97 Audio/oem21.inf]

PCI-Devices
   [1002:5B70]  ATI Technologies Inc. : Radeon X300/X550/X1050 Series Secondary (Microsoft Corporation - WDDM)
      Manually selected [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series Secondary (Microsoft Corporation - WDDM)
      Multiple selected [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series (Microsoft Corporation - WDDM)
   [10DE:0053]  (Standard-IDE-ATA/ATAPI-Controller) : Standard-Zweikanal-PCI-IDE-Controller
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/0053' not found
   [10DE:005D]  (Standardsystemgeräte) : PCI Standard-PCI-zu-PCI-Brücke
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/005D' not found
   [1022:1100]  AMD : AMD HyperTransport(tm)-Konfiguration
      Using build-in windows driver
   [10DE:0054]  (Standard-IDE-ATA/ATAPI-Controller) : Standard-Zweikanal-PCI-IDE-Controller
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/fsc__esprimo_p625/FTS_NVIDIASATAAHCIDRIVERVISTA64V103042MCP78__1026963/NVIDIA_SATA_AHCI_DRIVER_Vista64_V10.3.0.42_MCP78 (textmode capable)
   [1022:1101]  AMD : AMD-Adresszuordnungskonfiguration
      Using build-in windows driver
   [10DE:0055]  (Standard-IDE-ATA/ATAPI-Controller) : Standard-Zweikanal-PCI-IDE-Controller
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/fsc__esprimo_p625/FTS_NVIDIASATAAHCIDRIVERVISTA64V103042MCP78__1026963/NVIDIA_SATA_AHCI_DRIVER_Vista64_V10.3.0.42_MCP78 (textmode capable)
   [1022:1102]  AMD : AMD DRAM und HyperTransport(tm)-Nachverfolgungsmoduskonfiguration
      Using build-in windows driver
   [10DE:0057]  NVIDIA : NVIDIA nForce-Netzwerkcontroller
      Using build-in windows driver
   [1022:1103]  AMD : Sonstige AMD-Konfiguration
      Using build-in windows driver
   [10DE:0059]  Realtek : Realtek AC'97 Audio
      Manually selected [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/MEDIA/Realtek AC'97 Audio
   [10DE:005E]  NVIDIA : NVIDIA nForce4 HyperTransport-Brücke
      /var/lib/opsi/depot/<productid>/drivers/drivers/preferred/ga-ma78-pcbon4/chipset_win7-64/SMBUS
   [104C:8025]  Texas Instruments : OHCI-konformer Texas Instruments 1394-Hostcontroller
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/104C/8025' not found
   [10DE:005A]  (Standard-USB-Hostcontroller) : Standard OpenHCD USB-Hostcontroller
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/005A' not found
   [10DE:0050]  (StandardsystemgerÃ¤te) : PCI Standard-ISA-BrÃ¼cke
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/0050' not found
   [10DE:005B]  (Standard-USB-Hostcontroller) : Standard PCI-zu-USB erweiterter Hostcontroller
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/005B' not found
   [1002:5B60]  ATI Technologies Inc. : Radeon X300/X550/X1050 Series (Microsoft Corporation - WDDM)
      Manually selected [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series Secondary (Microsoft Corporation - WDDM)
      Multiple selected [/var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi] /var/lib/opsi/depot/<productid>/drivers/drivers/additional/byAudit/nvidia/awrdacpi/pctry5detlef/Display/Radeon X300-X550-X1050 Series (Microsoft Corporation - WDDM)
   [10DE:0052]  NVIDIA : NVIDIA nForce PCI-Systemverwaltung
      Using build-in windows driver
   [10DE:005C]  (StandardsystemgerÃ¤te) : PCI Standard-PCI-zu-PCI-Brücke
      No driver - device directory '/var/lib/opsi/depot/<productid>/drivers/pciids/10DE/005C' not found

USB-Devices
   [1241:1111]  (StandardsystemgerÃ¤te) : USB-Eingabegerät
      No driver - vendor directory '/var/lib/opsi/depot/<productid>/drivers/usbids/1241' not found

HD-Audio-Devices
   No devices installed
----

TIPPS::
* Treiberverzeichnisname `NDIS1` sind Vista-Treiber ; `NDIS2` sind Win7-Treiber

* Manche Chipsatztreiber enthalten Beschreibungsdateien, welche sehr viel Hardware aufführen ohne hierzu tatsächlich Treiber zu liefern. Ein Beispiel hierfür ist z.B. die `cougar.inf` oder `ibexahci.inf` von Intel. Wird ein solches 'Pseudo-Treiber' Verzeichnis per 'additional_drivers' (bzw. 'byAudit') zu geordnet, so führt dies dazu, das die hier aufgeführte Hardware von der weiteren Suche nach Treibern im 'preferred' Verzeichnis ausgeschlossen wird.

* SATA-Treiber und SATA-RAID Treiber beziehen sich auf die selbe PCI-Kennung. Ein SATA-RAID Treiber wird aber mit einem Einzelplatten System nicht funktionieren.

* Kontrollieren Sie die Ausgabe von `./show_drivers.py` genau !

[[opsi-getting-started-softwintegration]]
== Einbindung eigener Software in die Softwareverteilung von opsi

Die Installation von Software erfolgt bei opsi durch den {opsi-client-agent} und insbesondere durch das Script gesteuerte Setup Programm {opsi-winst}. Daher muss zu jedem opsi-Produkt ein opsi-winst-Script erstellt werden. Danach werden dieses Script, die Installationsdateien und die Metadaten zu einem opsi-Produkt gepackt, welches sich schließlich auf dem {opsi-Server} installieren lässt.

[[opsi-getting-started-softwintegration-tutorial]]
=== Ein kleines Tutorial zur Erstellung eines {opsi-winst} Scriptes

[[opsi-getting-started-softwintegration-tutorial-introduction]]
==== Einführung

Dieses Tutorial kann keine Schulung oder das Studium der Handbücher ersetzen. Es dient nur dazu eine Einführung zu bekommen. Daher als erstes der Verweis auf weiterführende Quellen:

.Schulungen:

Die uib GmbH bietet opsi-Schulungen in Mainz und Inhouse Schulungen an: +
https://uib.de/de/support-schulung/schulung/

.Handbücher:

https://uib.de/de/opsi-dokumentation/dokumentationen/ +
Besonders wichtig: +
opsi-winst-Reference-Card und opsi-winst-Handbuch

.Wiki (Scripte, Tipps, Links):

https://forum.opsi.org/wiki

.Support Forum:
siehe https://forum.opsi.org

[[opsi-getting-started-softwintegration-tutorial-general]]
==== Methoden der nicht interaktiven Softwareinstallation

Prinzipiell gibt es drei Verfahren der Einbindung eines Softwarepakets in die automatische Softwareverteilung für Windows-Betriebssysteme, zuzüglich einer Variante, die sich auf die Pakete für den Microsoft Installer Service bezieht.

. *Unattended / Silent Setup*: +
Das Original-Setupprogramm wird verwendet und über Kommandozeilenargumente in einen nicht-interaktiven Modus versetzt.
Der wichtigste Spezialfall davon ist der +
*„stille“ Aufruf eines MSI-Pakets*: +
Ein Paket für den Microsoft Installer Service ist vorhanden und wird mit einer „quiet“-Option aufgerufen.

. *Interaktives Setup mit automatisierten Antworten*: +
Zur Vorbereitung wird bei einem Lauf des Original-Setupprogramms festgestellt, welche Fenstertitel das Programm zeigt
und welche Fragen und Antworten beim Setup anfallen. Dies wird in einem Skript niedergeschrieben.
Im Prozess der Softwareverteilung läuft das Setupprogramm dann unter Kontrolle eines Automatisierungs-Programms
wie z.B. AutoIt oder Autohotkey, welches das Setupprogramm gemäß dem Skript steuert.

. *Nachbilden der Setup-Routine mit dem OPSI-Winst*: +
Bei einem Lauf des originalen Setupprogramms werden etwaige System-Änderungen mitprotokolliert, z.B. mit procmon und mit Hilfe des opsi-winst nachgefahren.

NOTE: Opsi unterstützt alle drei Varianten. In der Praxis werden sie häufig ergänzend verwendet.

[[opsi-getting-started-softwintegration-tutorial-script-structure]]
==== Struktur eines opsi-script / opsi-winst-Skripts

Zunächst ein Beispiel für ein einfaches opsi-winst-Skript:
[source,winst]
----
[Actions]
WinBatch_7z_silent_install

[WinBatch_7z_silent_install]
"%ScriptPath%\7z.exe" /S
----

Ein opsi-winst-Skript besteht aus *primären* und *sekundären* Sektionen.
Sektionen werden, wie von ini-Dateien bekannt, mit einem Sektions-Namen in eckigen Klammern eingeleitet. +
Die eigentlichen Arbeiten zur Software-Installation finden in den sekundären Sektionen statt,
die von den primären Sektionen aufgerufen werden.

Die sekundären Sektionen sind „Themen-spezifisch“ und verfügen jeweils über eine spezielle Syntax. +
Der Sektionsname einer sekundären Sektion beginnt mit deren Typ, gefolgt von einem frei definierbaren Namen.

Im Beispiel ruft die primären Sektion +[Actions]+  eine sekundäre Sektion +[WinBatch_7z_silent_install]+ auf. +
Die sekundäre Sektion ist vom Typ +WinBatch+. Der Inhalt einer +WinBatch+-Sektion wird über die Windows-API ausgeführt. +
In diesem Fall wird also das Setup-Programm `7z.exe` mit dem Parameter +/S+ gestartet.

[[opsi-getting-started-softwintegration-tutorial-primary-sections]]
==== Primäre Sektionen:

Actions/Aktionen::
Die +[Actions]+ Sektion ist das eigentliche Hauptprogramm. Hier beginnt die Skript-Verarbeitung.

Sub-Sektionen::
Programmabschnitte, die wiederholt benötigt werden, können in Sub-Sektionen (Unterprogramme) ausgelagert werden.
Es besteht die Möglichkeit Sub-Sektionen in externe Dateien auszulagern.

Die primären Sektionen sind das Hauptprogramm in dem der Ablauf des Skripts gesteuert wird. Hierzu gibt es:

* Variablen: Strings und Stringlisten
* +if+ +else+ +endif+ Anweisungen
* +for+ Schleifen über Stringlisten
* Funktionen

.Vermeidung doppelten Codes über ausgegliederte Sub
image::opsi-winst-delsub-schema.png["Abbildung: Vermeidung doppelten Codes über ausgegliederte Sub",width=400]

[[opsi-getting-started-softwintegration-tutorial-secondary-sections]]
==== Wichtige sekundäre Sektionen:

Files::
Datei-Operationen, wie:

* kopieren (mit Versionskontrolle, rekursiv ...)
* löschen
* Verzeichnisse anlegen
* ...

WinBatch::
Dient zum Aufrufen von Programmen über die Windows-API.
Beispielsweise werden Aufrufe von Setup-Programmen im silent mode in diesen Sektionen durchgeführt.

DosBatch/DosInAnIcon::
Der Inhalt dieser Sektionen wird der 'cmd.exe' zur Ausführung übergeben. Hier können also normale Batch-Skripte abgelegt werden. +
Eine Variante von 'DosBatch' ist 'DosInAnIcon', wobei die 'cmd.exe' mit minimiertem Fenster aufgerufen wird.

ExecWith::
Der Inhalt dieser Sektionen wird einem externen Programm (Interpreter) zur Ausführung übergeben.
Beispielsweise können über 'ExecWith' AutoIt-Skripte http://www.autoitscript.com direkt in das opsi-winst-Skript integriert werden.

Registry::
Die 'Registry-Sektionen' dienen dem Bearbeiten der Registry.

LinkFolder::
'LinkFolder-Sektionen' dienen dem Erstellen und Entfernen von Verknüpfungen.
Es können beispielsweise Verknüpfungen auf dem Desktop oder im Startmenü erstellt werden.


[[opsi-getting-started-softwintegration-tutorial-global-constants]]
==== Globale Konstanten

Globale Konstanten sind Text-Platzhalter, die in primären und sekundären Sektionen eingesetzt werden können
und zur Laufzeit textuell durch ihre Werte ersetzt werden. +
Über die Verwendung von Platzhaltern kann sichergestellt werden,
dass Pfade in unterschiedlichen Umgebungen (z.B. auf System mit unterschiedlichen Sprachen oder Betriebssystem-Versionen) richtig gesetzt sind.

Beispiele:

+%ProgramFiles32Dir%+:: c:\programme
+%Systemroot%+::        c:\windows
+%System%+::            c:\windows\system32
+%Systemdrive%+::       c:\
+%Scriptpath%+::        <Pfad zu laufenden Script>

[[opsi-getting-started-softwintegration-tutorial-second-example]]
==== Zweites Beispiel: tightvnc

Zur Erläuterung nun ein einfaches Script zur Installation von 'tightvnc'.
Eigentlich würde dieses Script mit dem Aufruf der Silent-Installation in der Winbatch-Sektion auskommen.
Bei einer wiederholten Installation erscheint hier (wegen des Neustarts eines laufenden Services) jedoch ein interaktiver Dialog.
Dieses Dialog-Fenster wird (so es auftaucht) mit Hilfe von 'AutoIt' geschlossen.

[source,winst]
----
[Actions]
Message "Installiere tightvnc 1.3.9 ..."
ExecWith_autoit_confirm "%ScriptPath%\autoit3.exe" WINST /letThemGo
WinBatch_tightvnc_silent_install
KillTask "autoit3.exe"

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent

[ExecWith_autoit_confirm]
; Wait for the confirm dialog which only appears if tightvnc was installed before as service
; Waiting for the window to appear
WinWait("Confirm")
; Activate (move focus to) window
WinActivate("Confirm")
; Choose answer no
Send("N")
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands]]
==== Elementare Befehle für primäre Sektionen

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-string-variable]]
===== String-Variable

Variablen-Deklaration:: 'DefVar <variable name>'

Variablen-Zuweisung:: 'Set <variable name> = <value>'

*Beispiel:*
[source,winst]
----
DefVar $ProductId$
Set $ProductId$ = "firefox"
----

IMPORTANT: Stringvariablen werden in primären und sekundären Sektionen unterschiedlich behandelt.
In primären Sektionen sind Stringvariablen eigenständige Objekte.
Nur hier können sie deklariert und ihnen Werte zugewiesen werden.
Entsprechend ist die Verbindung von Variablen und Strings zu einem Stringausdruck mit einem Operator `"+"` durchzuführen. +
Beispiel: `"Installing "+ $ProductId$ +" ..."` +
In sekundären Sektionen werden Stringvariablen vor der Ausführung der Sektion durch den Inhalt der Variable ersetzt. +
Beispiel: `"Installing $ProductId$ ..."` +
Dies ist zu beachten, wenn entsprechende Stringausdrücke per Cut&Paste im Skript kopiert werden. +
Der Vorteil dieser Konstruktion ist, dass in Sektionen die außerhalb des '{opsi-winst}' ausgeführt werden (DosBatch / Execwith)
problemlos mit opsi-winst-Variablen gearbeitet werden kann.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-message]]
===== Message / ShowBitmap

Zur Textausgabe während der Installation: +
`Message <string>`

*Beispiel:*
[source,winst]
----
Message "Installing "+ $ProductId$ +" ..."
----

Zur Ausgabe einer Grafik während der Installation: +
`ShowBitmap <filename> <subtitle>`

*Beispiel:*
[source,winst]
----
ShowBitmap "%ScriptPath%\python.png" "Python"
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-if-else-endif]]
===== if [else] endif

*Syntax:*
[source,winst]
----
if <condition>
	;statement(s)
[
else
	;statement(s)
]
endif
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-functions]]
===== Funktionen

HasMinimumSpace:: Prüft auf freien Platz auf der Festplatte.
FileExists:: Prüft auf Existenz einer Datei oder eines Verzeichnisses.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-error]]
===== Fehler, Logging und Kommentare

Kommentarzeichen ';':: Zeilen, die mit einem Semikolon (';') beginnen, werden nicht interpretiert.

Comment:: Schreibt eine Kommentar-Meldung in die Log-Datei.

LogError:: Schreibt eine Fehlermeldung in die Log-Datei.

IsFatalError:: Bricht die Ausführung des laufenden Skriptes ab und meldet die Installation als gescheitert zurück.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-requirements]]
===== Bedingung zur Ausführung

requiredWinstVersion:: gibt die (mindestens) benötigte opsi-winst Version an.

[[opsi-getting-started-softwintegration-tutorial-template]]
==== Drittes Beispiel: Standard-Template 'opsi-template'

Verwenden Sie dieses Template (bzw. eine aktualisierte Versionen von http://download.uib.de) als Basis für Ihre eigenen Skripte.
Das Template-Paket können Sie auf Ihrem Server mittels `opsi-package-manager` installieren (+-i+)
oder entpacken (+-x+), um an die enthaltenen Skripte zu gelangen.


.setup32.opsiscript: Installationsscript
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ProductId$
DefVar $MinimumSpace$
DefVar $InstallDir$
DefVar $ExitCode$
DefVar $LicenseRequired$
DefVar $LicenseKey$
DefVar $LicensePool$
DefVar $displayName32$
DefVar $displayName64$

DefStringlist $msilist$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
;$ProductId$ should be the name of the product in opsi
; therefore please: only lower letters, no umlauts,
; no white space use '-' as a seperator
Set $ProductId$       = "opsi-template"
Set $MinimumSpace$    = "1 MB"
; the path were we find the product after the installation
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------

if not(HasMinimumSpace ("%SystemDrive%", $MinimumSpace$))
	LogError "Not enough space on %SystemDrive%, " + $MinimumSpace$ + " on drive %SystemDrive% needed for " + $ProductId$
	isFatalError "No Space"
	; Stop process and set installation status to failed
else
	comment "Show product picture"
	ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

	if FileExists("%ScriptPath%\delsub32.opsiscript")
		comment "Start uninstall sub section"
		Sub "%ScriptPath%\delsub32.opsiscript"
	endif

	Message "Installing " + $ProductId$ + " ..."

	if $LicenseRequired$ = "true"
		comment "Licensing required, reserve license and get license key"
		Sub_get_licensekey
	endif

	comment "Start setup program"
	ChangeDirectory "%SCRIPTPATH%"
	Winbatch_install
	Sub_check_exitcode

	comment "Copy files"
	Files_install /32Bit

	comment "Patch Registry"
	Registry_install /32Bit

	comment "Create shortcuts"
	LinkFolder_install

endif

[Winbatch_install]
; Choose one of the following examples as basis for your installation
; You can use $LicenseKey$ var to pass a license key to the installer
;
; === Nullsoft Scriptable Install System ================================================================
; "%ScriptPath%\Setup.exe" /S
;
; === MSI package =======================================================================================
; You may use the parameter PIDKEY=$Licensekey$
; msiexec /i "%ScriptPath%\some.msi" /l* "$LogDir$\$ProductId$.install_log.txt" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
;
; === InstallShield + MSI=====================================================================================
; Attention: The path to the log file should not contain any whitespaces
; "%ScriptPath%\setup.exe" /s /v" /l* $LogDir$\$ProductId$.install_log.txt /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
; "%ScriptPath%\setup.exe" /s /v" /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
;
; === InstallShield =====================================================================================
; Create setup.iss answer file by running: setup.exe /r /f1"c:\setup.iss"
; You may use an answer file by the parameter /f1"c:\setup.iss"
; "%ScriptPath%\setup.exe" /s /sms /f2"$LogDir$\$ProductId$.install_log.txt"
;
; === Inno Setup ========================================================================================
; http://unattended.sourceforge.net/InnoSetup_Switches_ExitCodes.html
; You may create setup answer file by: setup.exe /SAVEINF="filename"
; You may use an answer file by the parameter /LOADINF="filename"
; "%ScriptPath%\setup.exe" /sp- /silent /norestart /nocancel /SUPPRESSMSGBOXES

[Files_install]
; Example of recursively copying some files into the installation directory:
;
; copy -s "%ScriptPath%\files\*.*" "$InstallDir$"

[Registry_install]
; Example of setting some values of an registry key:
;
; openkey [HKEY_LOCAL_MACHINE\Software\$ProductId$]
; set "name1" = "some string value"
; set "name2" = REG_DWORD:0001
; set "name3" = REG_BINARY:00 af 99 cd

[LinkFolder_install]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of creating an shortcut to the installed exe in AllUsers startmenu:
;
; set_basefolder common_programs
; set_subfolder $ProductId$
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters:
; 	working_dir: $InstallDir$
; 	icon_file:
; 	icon_index:
; end_link
;
; Example of creating an shortcut to the installed exe on AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters: <some_param>
; 	working_dir: $InstallDir$
; 	icon_file: <path to icon file>
; 	icon_index: 2
; end_link

[Sub_get_licensekey]
if opsiLicenseManagementEnabled
	comment "License management is enabled and will be used"

	comment "Trying to get a license key"
	Set $LicenseKey$ = demandLicenseKey ($LicensePool$)
	; If there is an assignment of exactly one licensepool to the product the following call is possible:
	; Set $LicenseKey$ = demandLicenseKey ("", $ProductId$)
	;
	; If there is an assignment of a license pool to a windows software id, it is possible to use:
	; DefVar $WindowsSoftwareId$
	; $WindowsSoftwareId$ = "..."
	; Set $LicenseKey$ = demandLicenseKey ("", "", $WindowsSoftwareId$)

	DefVar $ServiceErrorClass$
	set $ServiceErrorClass$ = getLastServiceErrorClass
	comment "Error class: " + $ServiceErrorClass$

	if $ServiceErrorClass$ = "None"
		comment "Everything fine, we got the license key '" + $LicenseKey$ + "'"
	else
		if $ServiceErrorClass$ = "LicenseConfigurationError"
			LogError "Fatal: license configuration must be corrected"
			LogError getLastServiceErrorMessage
			isFatalError
		else
			if $ServiceErrorClass$ = "LicenseMissingError"
				LogError "Fatal: required license is not supplied"
				isFatalError
			endif
		endif
	endif
else
	LogError "Fatal: license required, but license management not enabled"
	isFatalError
endif


[Sub_check_exitcode]
comment "Test for installation success via exit code"
set $ExitCode$ = getLastExitCode
; informations to exit codes see
; http://msdn.microsoft.com/en-us/library/aa372835(VS.85).aspx
; http://msdn.microsoft.com/en-us/library/aa368542.aspx
if ($ExitCode$ = "0")
	comment "Looks good: setup program gives exitcode zero"
else
	comment "Setup program gives a exitcode unequal zero: " + $ExitCode$
	if ($ExitCode$ = "1605")
		comment "ERROR_UNKNOWN_PRODUCT	1605	This action is only valid for products that are currently installed."
		comment "Uninstall of a not installed product failed - no problem"
	else
		if ($ExitCode$ = "1641")
			comment "looks good: setup program gives exitcode 1641"
			comment "ERROR_SUCCESS_REBOOT_INITIATED	1641	The installer has initiated a restart. This message is indicative of a success."
		else
			if ($ExitCode$ = "3010")
				comment "looks good: setup program gives exitcode 3010"
				comment "ERROR_SUCCESS_REBOOT_REQUIRED	3010	A restart is required to complete the install. This message is indicative of a success."
			else
				logError "Fatal: Setup program gives an unknown exitcode unequal zero: " + $ExitCode$
				isFatalError
			endif
		endif
	endif
endif
----

.delsub32.opsiscript: Ausgelagerte Deinstallations-Sub-Sektion
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib gmbh
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

Set $MsiId$ = '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'
Set $UninstallProgram$ = $InstallDir$ + "\uninstall.exe"

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists($UninstallProgram$)
	comment "Uninstall program found, starting uninstall"
	Winbatch_uninstall
	sub_check_exitcode
endif
if not (GetRegistryStringValue32("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" + $MsiId$ + "] DisplayName") = "")
	comment "MSI id " + $MsiId$ + " found in registry, starting msiexec to uninstall"
	Winbatch_uninstall_msi
	sub_check_exitcode
endif

comment "Delete files"
Files_uninstall /32Bit

comment "Cleanup registry"
Registry_uninstall /32Bit

comment "Delete program shortcuts"
LinkFolder_uninstall

[Winbatch_uninstall]
; Choose one of the following examples as basis for program uninstall
;
; === Nullsoft Scriptable Install System ================================================================
; maybe better called as
; Winbatch_uninstall /WaitforProcessending "Au_.exe" /Timeoutseconds 10
; "$UninstallProgram$" /S
;
; === Inno Setup ========================================================================================
; "$UninstallProgram$" /silent /norestart /SUPPRESSMSGBOXES /nocancel

[Winbatch_uninstall_msi]
msiexec /x $MsiId$ /qb-! REBOOT=ReallySuppress

[Files_uninstall]
; Example for recursively deleting the installation directory:
;
; del -sf "$InstallDir$\"

[Registry_uninstall]
; Example of deleting a registry key:
;
; deletekey [HKEY_LOCAL_MACHINE\Software\$ProductId$]

[LinkFolder_uninstall]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of deleting a shortcut from AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
; delete_element $ProductId$


[Sub_check_exitcode]
;(.... siehe oben .....)
----

.uninstall32.opsiscript: Deinstallations-Skript
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ExitCode$
DefVar $ProductId$
DefVar $InstallDir$
DefVar $LicenseRequired$
DefVar $LicensePool$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
Set $ProductId$       = "opsi-template"
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------


comment "Show product picture"
ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists("%ScriptPath%\delsub32.opsiscript")
	comment "Start uninstall sub section"
	Sub "%ScriptPath%\delsub32.opsiscript"
endif

if $LicenseRequired$ = "true"
	comment "Licensing required, free license used"
	Sub_free_license
endif

[Sub_free_license]
comment "License management is enabled and will be used"

comment "Trying to free license used for the product"
DefVar $result$
Set $result$ = FreeLicense($LicensePool$)
; If there is an assignment of a license pool to the product, it is possible to use
; Set $result$ = FreeLicense("", $ProductId$)
;
; If there is an assignment of a license pool to a windows software id, it is possible to use
; DefVar $WindowsSoftwareId$
; $WindowsSoftwareId$ = "..."
; set $result$ = FreeLicense("", "", $WindowsSoftwareId$)
----

[[opsi-getting-started-softwintegration-tutorial-create-and-test-script]]
==== Interaktives Erstellen und Testen eines {opsi-winst} Skriptes

Sie können ein Skript interaktiv anpassen und testen.

Erstellen Sie sich dazu ein Verzeichnis (z.B. `c:\test`) und kopieren Sie die Scripte des opsi-template (`setup.ins`, `delsub.ins` und `uninstall.ins`) in dieses Verzeichnis.

Starten Sie {opsi-winst} (`winst32.exe`) per Doppelklick. (Beim Starten des {opsi-winst} auf einem Windows 7 Client muss "ausführen als Administrator" über die rechte Maustaste verwendet werden.) Wenn der `opsi-client-agent` bereits auf Ihrem Rechner installiert ist, finden Sie {opsi-winst}
unter `C:\Programme\opsi.org\opsi-client-agent\opsi-winst`.
Wenn nicht, kopieren Sie sich das Verzeichnis `opsi-winst` vom share `\\<opsiserver\opsi_depot_rw`, aus dem Verzeichnis `install\opsi-winst\files.`
Sie sehen dann folgendes Fenster:

.opsi-winst im interaktiven Modus
image::winst-interaktiv.png["Screenshot: {opsi-winst} im interaktiven Modus",400]

Über 'Select Script' können Sie das Skript auswählen, dass Sie ausführen möchten.
Mit 'Start' können Sie das Script starten. Dabei wird das Script auf diesem Rechner ausgeführt.
Über 'View Log' können Sie sich die Log-Datei des Skript-Laufes anschauen.

.opsi-winst Log View Fenster
image::winst-log-view.png[Screenshot: opsi-winst Log View Fenster]

* Schauen Sie sich anhand der Log-Datei an, wie der {opsi-winst} das Skript interpretiert.

* Kopieren Sie die `Setup.exe`, welche Sie installieren wollen, in das Verzeichnis, in dem die Skripte liegen (z.B. `c:\test`).

* Öffenen Sie das Script `setup.ins` in einem Editor.
Im Prinzip können Sie jeden beliebigen Editor verwenden.
Wir empfehlen den Editor 'jEdit' mit {opsi-winst} Syntax-Highlighting, wie Sie ihn in der Grundausstattung der opsi-Produkte finden.

.jEdit mit einem opsi script
image::jedit-with-winst-script.png["jEdit with a opsi script",400]


* Sie können nun das Skript im Editor anpassen und speichern (Sie können den Editor geöffnet lassen).
Wechseln Sie zum opsi-winst-Fenster und starten Sie das Skript erneut über den Knopf 'Start' (das Skript muss nicht neu ausgewählt werden).
Schauen Sie sich das auf Basis Ihrer Änderungen im Skript veränderte Log über `View Log` an.

* Auf diese Art und Weise, also über die Wiederholung der Punkte: +
 - Anpassung des Skriptes und speichern +
 - Skript ausführen +
 - Log überprüfen +
können Sie nach und nach Ihre Skripte so anpassen, dass sie das tun, was Sie wünschen.

Hinweise zur Lösung von Detail-Problemen finden Sie im nächsten Kapitel.
Im übernächsten Kapitel wird erklärt, wie Sie aus den so erstellten Skripten ein opsi-Produkt erstellen, das Sie auf dem {opsi-server} installieren können.

[[opsi-getting-started-softwintegration-tutorial-template-details]]
==== Hinweise zu den Teilaufgaben im opsi-template

[[opsi-getting-started-softwintegration-tutorial-find-switches]]
===== Silent oder Unattended Schalter finden

Beim „unattended“ oder „silent setup“  wird das Original-Setup-Programm über Kommandozeilen-Argumente in einen nicht interaktiven Modus gestellt.

Das Problem dieser Installationsmethode ist es die geeigneten Kommandozeilenargumente zu finden.

.Suche in Schaltersammlungen im Internet:
Bevor man sich in Forschungen stürzt, ist dringend zu empfehlen bei opsi.org zu schauen, ob jemand das Problem bereits gelöst hat:

Fertige opsi-winst-Skripte aus der Community gibt es im link:https://forum.opsi.org/wiki/[opsi community Wiki].

Eine Sammlung von Weblinks zu Schaltersammlungen im Internet findet sich im link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi Wiki: Software integration web-links].

.Ermitteln des Herstellers des Setup-Programms:
Die meisten Setupprogramme sind auf Basis von Frameworks wie 'Inno', 'NSIS', 'Installshield' oder 'Wise' gebaut. Jedes dieser Frameworks hat eigene typische Setupschalter. Um das Framework zu ermitteln kann unter anderem folgende Methode verwendet werden: Mit dem Kommandozeilen Programm `strings` werden die Strings aus der `setup.exe` extrahiert und danach mit `grep` bzw. `findstr` nach den Namen der Frameworks gesucht.

Unter Linux sieht der dazu nötige Befehl wie folgt aus (setzen Sie für <mysetup.exe> den Namen Ihrer setup.exe ein):

[source,prompt]
----
strings <mysetup.exe> | grep -i -E "(inno|nsis|installshield|wise)"
----

Unter Windows muss der Befehl `strings.exe` erst installiert werden. Einen entsprechenden Download findet man hier: http://technet.microsoft.com/en-us/sysinternals/bb897439

Unter Verwendung dieses Programms, sieht der Befehl unter Windows dann wie folgt aus (setzen Sie für <mysetup.exe> den Namen Ihrer setup.exe ein):
[source,prompt]
----
strings.exe <mysetup.exe> | findstr /i /r "inno installshield nsis wise"
----

Die selbe Methode verwendet der `opsi-setup-detector`.

.opsi setup detector
image::opsi-setup-detector.png[width="100mm"]

Dieses grafisch-interaktive Programm lässt sich zudem in das Kontextmenü des Explorers Einbinden.

.opsi setup detector im Kontextmenü des Explorers
image::opsi-setup-detector-context-small-de.png[width="75mm"]

Der 'opsi setup detector' ist Bestandteil der opsi-Repositories für Windows und kann über diese bezogen werden.

.Suche beim Hersteller des Setup-Programms:
Setup-Programme werden in der Regel von den Herstellern der diversen Softwareprodukte nicht selbst geschrieben.
In den meisten Fällen bedienen sich vielmehr die Produkthersteller selbst spezieller Softwareprodukte,
mit denen Setup-Programme relativ einfach erstellt werden können.
Die verwendbaren Kommandozeilenargumente sind daher zumeist typisch für das verwendete Produkt zur Erstellung von Setup-Programmen.

Im link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi Wiki: Software integration web-links] finden weitere Weblinks zu Seiten, die erläutern, wie man Setupprogramme erkennt und wie Ihre typischen Schalter sind.

Auf der Homepage des Herstellers des Setupprogramms wird man zumeist mit der Suche nach Stichworten wie "silent", "silent Install" oder "unattended" fündig.

.Suche beim Hersteller des Programms:
Da die Anforderung einer automatischen Installation inzwischen vielen Herstellern bewusst ist,
finden sich häufig in der Produkt-Dokumentation oder auf der Homepage des Herstellers Anleitungen oder Hinweise hierzu.

[[opsi-getting-started-softwintegration-tutorial-winst-commands]]
===== Weitere wichtige {opsi-winst} Funktionen

Einen Überblick über die {opsi-winst} Funktionen gibt die Referencecard: +
http://download.uib.de/opsi4.0/doc/opsi-winst-reference-card-en.pdf

Eine detaillierte Dokumentation ist im {opsi-winst} Handbuch zu finden: +
http://download.uib.de/opsi4.0/doc/opsi-winst-manual-de.pdf

Hier noch einige Hinweise auf besonders wichtige Elemente:

.Stringlisten:
Stringlisten sind sehr mächtig, insbesondere zur Auswertung von Ausgaben externer Programme. Lesen Sie dazu die opsi-winst-Dokus.

.ExitWindows:
Neustart/Herunterfahren des Systems und Beendung des {opsi-winst}.

*  `ExitWindows /Reboot` +
Rechner-Neustart nach Abschluss des laufenden Skriptes.

*  `ExitWindows /ImmediateReboot` +
Sofortiger Neustart.

*  `ExitWindows /ImmediateLogout` +
Sofortige Beendigung der Skript-Bearbeitung und Beendung des {opsi-winst}.

.{product-properties}:
Für manche Produkte ist es erforderlich, Optionen zur Verfügung zu stellen.
Diese werden zur Laufzeit Client-spezifisch ausgewertet.
Wie solche Properties erstellt werden, ist im Kapitel
<<opsi-getting-started-softwintegration-create-opsi-package,Erstellen eines opsi-Produkt-Pakets>> beschrieben.

Der Zugriff auf die Werte der Properties geschieht über die Funktion +GetProductProperty+:

[source,winst]
----
if GetProductProperty("example-property", "no") = "yes"
	Files_copy_extra_files
endif
----

[[opsi-getting-started-softwintegration-tutorial-opsiadmin]]
===== Installation mit angemeldetem Benutzer

Vereinzelt taucht das Problem auf, dass sich Installationen nur bei angemeldetem Benutzer durchführen lassen.
Ein Hinweis auf diese Problematik ist es, wenn ein opsi-winst-Skript das eine unattended Installation enthält,
beim manuellen Aufruf durch einen administrativen Benutzer funktioniert, im Rahmen der automatischen Installation über opsi jedoch scheitert.

Eine mögliche Ursache ist dann, dass dieses Setupprogramm einen angemeldetem Benutzer bzw. den Zugriff auf ein Benutzer-Profil benötigt.
Handelt es sich um eine MSI-Installation, hilft eventuell die Option +ALLUSERS=1+.

.Beispiel:
[source,winst]
----
[Actions]
DefVar $MsiLogFile$
Set $MsiLogFile$ = %opsiLogDir% + "\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb-! /l* $MsiLogFile$ /i "%ScriptPath%\files\myproduct.msi" ALLUSERS=1
----

Eine weitere Möglichkeit ist, dass sich das Installationsprogramm zu früh beendet, z.B. weil ein ein Sub-Prozess gestartet wird.
In diesem Fall können die Parameter +/WaitSeconds <Anzahl Sekunden>+ oder
+/WaitForProcessEnding "program.exe" /TimeOutSeconds "<Anzahl Sekunden>"+ für den WinBatch-Aufruf helfen.

Eine andere, wenn auch aufwendigere, Möglichkeit dieses Problem zu lösen ist, einen administrativen Benutzer temporär anzulegen
und diesen zur Installation der Software zu verwenden. Dies können Sie auf Basis des Templates 'opsi-template-with-admin' durchführen.

[[opsi-getting-started-softwintegration-tutorial-msi]]
===== Arbeiten mit MSI-Paketen

Microsoft hat mit Windows 2000 ein eigenes Installationskonzept vorgestellt, das auf dem Microsoft Installer Service, kurz „MSI“ beruht. Inzwischen sind viele Setup-Programme MSI-konform.

MSI-Konformität bedeutet, dass die eigentliche Installation darin besteht, dass an den MSI ein Paket von Installations-Anweisungen übergeben wird (im Prinzip eine Datei mit einen Namen der Form „produkt.msi“) und der MSI dieses Paket dann ausführt.

In der Praxis sieht dies meist so aus, dass die zu einem Produkt gehörige „setup.exe“ eine Datei „produkt.msi“ und ein zusätzliches Steuerprogramm für die Installation enthält. Das Steuerprogramm packt „produkt.msi“ aus und fragt, ob eine Installation starten soll. Wird dies bestätigt, prüft das Steuerprogramm, ob der MSI schon eingerichtet ist und übergibt bei positivem Ergebnis der Prüfung diesem die „produkt.msi“. Ist der MSI nicht eingerichtet und wird insbesondere das Programm „msiexec.exe“ nicht gefunden, so startet das Steuerprogramm zuerst eine Installationsprogramm für den MSI.

Klickt man bei der Frage, ob die Installation starten soll, nicht auf „weiter“, sondern ruft den Explorer auf, so findet sich das ausgepackte MSI-Paket meist in einem temporären Verzeichnis.

Dieses Paket kann nun dazu verwendet werden, eine Installation „unattended“ - also „unbewacht“,  d.h. ohne dass ein Benutzereingriff erforderlich ist - auszuführen. Dazu ist bei vorhandener `msiexec.exe` aufzurufen:
[source,winst]
----
msiexec /i "%ScriptPath%\Product.msi" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
----

[[opsi-getting-started-softwintegration-tutorial-customizing]]
===== Customizing nach einer silent/unattended Installation

Häufig will man nach einer erfolgreichen Silent-Installation Anpassungen an der Installation vornehmen.
Hierzu bietet der {opsi-winst} ein mächtiges Werkzeug.
Doch bevor dies eingesetzt werden kann muss oft ermittelt werden, welche in der graphischen Oberfläche getätigten Änderungen zu
welchen Veränderungen in Dateien und der Registry führen.

Hierzu können die unter <<opsi-getting-started-softwintegration-tutorial-analyse-and-repackage>> vorgestellten Werkzeuge eingesetzt werden.
Häufig führen aber auch kleinere Werkzeuge schneller zum Erfolg.

Einige beliebte Werkzeuge sind:

* link:http://www.sysinternals.com/[sysinternals]
* link:https://sourceforge.net/projects/regshot/[regshort]

[[opsi-getting-started-softwintegration-tutorial-autoit]]
===== Einbindung mittels interaktiven Setup-Programms und automatisierten Antworten

Eine weitere schnelle Möglichkeit zur Einbindung in die automatische Softwareverteilung ist das 'Setup mit automatisierten Antworten'.
Hierzu wird eine Steuerungs-Software verwendet, die über ein Skript die Interaktion eines Anwenders mit den erscheinenden Dialog-Fenstern automatisiert. +
Wir empfehlen hierfür den Einsatz der Software link:https://autohotkey.com[AutoHotkey] oder link:http://www.autoitscript.com[AutoIt].

'AutoIt' bietet eine ganze Reihe zusätzlicher Möglichkeiten, den Setup-Prozess zu steuern.
Auch eventuelle Fehlerzustände können (so vorher bekannt) mit dem Einsatz von +[ADLIB]+-Sektionen im Skript abgefangen werden.

Ein prinzipielles Problem bleibt bestehen: Nicht vorhergesehene (und im Skript berücksichtigte) Fenster können das Skript zum Stoppen bringen.

Außerdem kann der Anwender mittels Maus und Tastatur (wenn diese nicht gesperrt sind) in den automatisierten Prozess eingreifen und den Ablauf damit verändern.
Ein Unattended- oder Silent-Setup ist daher immer die bessere Lösung.

Sehr gut kann auch eine Kombination aus beiden Ansätzen funktionieren:
Das Silent-Setup übernimmt die eigentliche Installation und ein AutoIt-Skript fängt bekannte Sonderbedingungen ab.

Wenn das Ausführen von Installationen in der opsi-client-agent Konfiguration auf einen anderen Desktop verlegt wird oder der Desktop gesperrt wird, haben verschiedene autoit Funktionen Probleme.

Daher sollten in '{opsi-winst}' Skripten die folgenden Funktionen gemieden werden:

* winwait()

* winactivate()

* Send()

Das sind leider genau die 3 am meisten verwendeten.

*winwait()* +
kann ersetzt werden durch die Funktion +
`opsiwinwait($title, $text, $maxseconds, $logname)` +
welche in der folgenden Weise definiert wird:
[source,configfile]
----
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

----
Dabei ist:

* `$title` der Titel des Fensters

* `$text` ein Teil des sichtbaren Textes im Fenster

* `$maxseconds` der timeout in Sekunden

* `$logname` der Name der Logdatei


*Send()* +
kann ersetzt werden durch die Funktion +
`opsiControlClick($title, $text, $id, $maxseconds, $logname)` +
bzw. durch +
`opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)` +
welche in der folgenden Weise definiert werden:
[source,configfile]
----
Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title , $text,$id)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

----
Dabei ist:

* `$title` der Titel des Fensters

* `$text` ein Teil des sichtbaren Textes im Fenster

* `$id` die numerische ControlId des Buttons oder Editierfeldes

* `$sendtext` der Text welcher eingfügt werden soll

* `$maxseconds` der timeout in Sekunden

* `$logname` der Name der Logdatei

Dabei muss mit der `Au3info.exe` die 'ControlId' ermittelt werden. Bitte die numerische 'ControlId' verwenden, andere Varianten scheinen Probleme zu machen:

Hier ein Auszug aus einem script. +
In diesem wird dann noch eine Logdatei angelegt, die mit folgenden Befehlen in die Logdatei des '{opsi-winst}' integriert wird:
[source,winst]
----
includelog "c:\tmp\au3.log" "500"
----

Das Beispiel:
[source,configfile]
----
[ExecWith_autoit_confirm]
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title , $text,$id)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

; exact title match
Opt("WinTitleMatchMode", 3)
$mylog = FileOpen("%opsiLogDir%\au3.log", 2)
FileWriteLine($mylog,"auto-it started - waiting for the window")
FileClose($mylog)

opsiwinwait("InstallShield Wizard" , "Wollen Sie wirklich", 200, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Wollen Sie wirklich", 6, 5, "%opsiLogDir%\au3.log")
opsiwinwait("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 400, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 1, 5, "%opsiLogDir%\au3.log")

Sleep(500)
;and good bye
Exit
----

siehe auch: +
http://www.autoitscript.com/wiki/FAQ#Why_doesn.27t_my_script_work_on_a_locked_workstation.3F +
http://www.autoitscript.com/autoit3/docs/ +
http://www.autoitscript.com/autoit3/docs/intro/controls.htm +
http://www.autoitscript.com/autoit3/docs/functions.htm




[[opsi-getting-started-softwintegration-tutorial-analyse-and-repackage]]
===== Analyse und Neu-Paketieren

Wenn der Entwickler einer Anwendung ein Paket zur Auslieferung der Anwendung schnürt, kennt er die benötigten Komponenten.
Im Nachhinein, wenn schon ein Paket existiert, das mittels eines Setup-Programm zu installieren ist,
kann die Kenntnis, welche Komponenten installiert werden müssen, damit eine Anwendung wie gewünscht auf einem Arbeitsplatzrechner lauffähig ist,
aus der Studie der Effekte bei der Ausführung des vorhandenen Setup-Programms gewonnen werden.

Eine Reihe von Werkzeuge zum Analysieren von Setup-Programmen kommen hierbei in Frage. So z.B.:

* link:http://download.fyxm.net/download-now-InstallWatch-Pro-OS-OS-Info-83813.html[InstallWatch Pro]

* link:http://www.itninja.com/media/downloads/appdeploy-repackager.msi[appdeploy-repackager]

[[opsi-getting-started-softwintegration-tutorial-deinstall]]
===== Verfahren zur Deinstallation von Produkten

Um eine installierte Software von einem Rechner zu entfernen, kann ein Deinstallations-Skript erstellt werden.
Grundsätzlich besteht bei einer Deinstallation die Schwierigkeit, dass nicht immer klar ist,
wie das Produkt auf dem Rechner vorliegt und was alles entfernt werden muss.
Auch nach der Installation können neue Dateien oder Registry-Einträge, die die Software betreffen, hinzugekommen sein.
Weiterhin muss darauf geachtet werden nicht zu viel zu entfernen, um die Systemstabilität nicht zu gefährden.
Meist weiß nur der Hersteller genau, wie mit seinem Produkt bei der Deinstallation umzugehen ist.
Ähnlich wie bei der Installation, existieren zu diesem Zweck Deinstallations-Routinen, die dem Produkt beiliegen.
Wenn es die Möglichkeit gibt, diese ohne Benutzer-Interaktion auszuführen, kann dies schon ein entscheidender Schritt sein.
Ist eine solche Routine nicht vorhanden oder muss diese erweitert werden, so existieren viele opsi-winst-Befehle, die zur Deinstallation nützlich sein können.
Im Folgenden soll nun ein Überblick über Möglichkeiten zur Deinstallation gegeben werden, die durch Beispiele verdeutlicht werden.

.Verwenden einer Deinstallations-Routine

Liefert der Hersteller des Produkts ein Programm (oder ein MSI-Paket) zur Deinstallation, so muss zunächst geprüft werden,
ob dies auch ohne Benutzer-Interaktion ausgeführt werden kann (silent-mode).
Sollte dies nicht von Hause aus möglich sein, kann der Einsatz eines AutoIt-Skriptes in Verbindung mit der Deinstallations-Routine hilfreich sein.
Der Aufruf der ausführbaren Datei kann im opsi-winst-Skript in einer Winbatch-Sektion geschehen, z.B.:

[source,winst]
----
[WinBatch_start_ThunderbirdUninstall]
"%SystemRoot%\UninstallThunderbird.exe" /ma
----

Trotz dieser Unterstützung des Herstellers sollte man sich jedoch nicht auf die korrekte Beseitigung des Produkts verlassen
und auf einem Testsystem zusätzlich prüfen, ob das System nach der Deinstallation weiter stabil läuft und ob Dateien oder
Registry-Einträge zurückgeblieben sind.

Falls das Produkt als MSI-Paket bereitgestellt und mittels 'msiexec' installiert wurde,
ist es in der Regel auch eine Deinstallation mittels 'msiexec' möglich.
Dazu ruft man den `msiexec.exe` mit dem Parameter +/x+ auf und übergibt zusätzlich den MSI-Paket oder dessen 'GUID' an.
Um die Benutzer-Interaktion zu deaktivieren, kann zusätzlich der Parameter +/qb-!+ übergeben werden. +
Dies ergibt nun den folgenden Aufruf:

[source,winst]
----
msiexec.exe /x some.msi /qb-! REBOOT=ReallySuppress
----

Statt das MSI-Paket zu übergeben, gibt es auch die Möglichkeit die 'GUID' an `msiexec.exe` zu übergeben.
Diese ID ist eindeutig, Produkt-spezifisch und auf allen Systemen, auf denen das MSI-Paket installiert ist, gleich.
Sie findet sich zum Beispiel im Zweig
+HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall+ der Registry. +
Ein Beispiel einer Deinstallation mittels dieser GUID sieht folgendermaßen aus:

[source,winst]
----
msiexec.exe /x {003C5074-EB37-4A75-AC4B-F5394E08B4DD} /qb-!
----

Sollten diese Methoden nicht oder nicht vollständig funktionieren, so muss mit einem opsi-winst-Skript nachgeholfen werden,
wie es im nächsten Abschnitt beschrieben ist.

.Nützliche opsi-winst-Befehle zur Deinstallation

Wurde ein Produkt mit den opsi-winst-Funktionen installiert oder gibt es keine Deinstallation vom Hersteller,
so muss ein eigenes opsi-winst-Skript zu Deinstallation geschrieben werden.
Um den Programmierer bei dieser Arbeit zu unterstützen stellt der '{opsi-winst}' einige Funktionen bereit,
die speziell bei der Deinstallation notwendig oder hilfreich sind.
Es soll an dieser Stelle nur ein kurzer Überblick gegeben werden,
eine genaue Beschreibung der Befehle und deren Parameter findet sich im {opsi-winst}-Handbuch.

Der einfachste Fall ist das Löschen einer oder mehrerer Dateien vom System. Dies geschieht in einer Files-Sektion mittels des Befehls

[source,winst]
----
delete -f Dateiname
----

oder für ein Verzeichnis mit Unterverzeichnissen

[source,winst]
----
delete -sf Verzeichnisname\
----

Der Parameter +f+ steht dabei für force, um die Datei wirklich zu löschen, auch wenn diese schreibgeschützt ist,
der Parameter +s+ für subdirectories (mit Unterverzeichnissen/rekursiv).
Soll eine Datei oder ein Verzeichnis aus allen Benutzer-Profilen gelöscht werden,
so kann diese Files-Sektion mit dem Parameter +/AllNTUserProfiles+ aufgerufen werden. (siehe {opsi-winst}-Handbuch)

Möchte man einen Verzeichnisbaum löschen, in dem sich auch Dateien mit dem Attribut „versteckt“ oder „systemdatei“ befinden,
muss momentan ein Umweg über den Befehl `rmdir` gegangen werden, der über eine 'DosInAnIcon'-Sektion aufgerufen werden kann.

[source,winst]
----
[DosInAnIcon_deleteDir]
rmdir /S /Q "<Verzeichnis>"
----

Muss vor dem Löschen evtl. ein laufender Prozess beendet werden, so kann dies mit dem Namen des Prozesses (zu sehen im Task-Manager)
und dem opsi-winst-Befehl +KillTask+ geschehen:

[source,winst]
----
KillTask "thunderbird.exe"
----

Sollte das Produkt – oder Teile davon – als Service laufen, so muss dieser vor der Deinstallation beendet werden.
Man kann dazu den Service in der Registry auf “inaktiv“ schalten und den Rechner neu starten oder aber man benutzt den System-Befehl
`net` mit dem Parameter +stop+, um den Service sofort zu stoppen und anschließend – ohne Neustart – die zugehörigen Dateien zu löschen.

[source,winst]
----
net stop <servicename>
----

Besondere Vorsicht ist beim Löschen von .dll-Dateien geboten, die noch von anderen Produkten verwendet werden könnten.
Sie müssen individuell behandelt werden, weshalb hier leider kein allgemein gültiges Rezept gegeben werden kann.

Um einzelne Einträge aus der Registry mittels {opsi-winst} zu löschen, kommt der Befehl +DeleteVar+ zum Einsatz,
der innerhalb einer 'Registry'-Sektion eines {opsi-winst}-Skripts verwendet werden kann.
Er löscht Einträge aus dem momentan geöffneten Key:

[source,winst]
----
DeleteVar <VarName>
----

Möchte man einen Registry-Key samt seiner Unterschlüssel und Registry-Variablen löschen, so geschieht dies mittels des {opsi-winst}-Befehls +DeleteKey+, z.B.:

[source,winst]
----
DeleteKey [HKLM\Software\Macromedia]
----

[[opsi-getting-started-softwintegration-tutorial-64bit]]
===== Bekannte Besonderheiten der 64 Bit-Unterstützung

Der {opsi-winst} ist ein 32-Bit Programm.
Skripte zur Installation von 32-Bit Programmen funktionieren in der Regel auch auf 64-Bit Systemen korrekt.
Einige Konstanten, wie +%ProgramFilesDir%+, liefern Werte, die für die Verwendung mit 64-Bit-Programmen nicht richtig sind.
Neuere {opsi-winst}-Versionen kennen spezielle Befehle und Konstanten für 64-Bit-Systeme.
Beachten Sie beim Arbeiten auf 64-Bit-Systemen das entsprechende Kapitel im {opsi-winst}-Handbuch.

[[opsi-getting-started-softwintegration-create-opsi-package]]
=== Erstellen eines opsi-Produkt-Pakets

In opsi werden die Installationsdateien, das opsi-winst-Skript zur Installation auf den Client und die Metadaten zu einem Paket zusammengefasst, welches zur Installation dieses Softwareproduktes auf einem {opsi-server} dient.

Die wesentlichen Vorteile dieses Paketformates sind:

* Einfache menügeführte Erstellung mit dem Programm `opsi-newprod`.

* Ablage aller relevanten Metadaten in einer einfach zu editierenden Datei.

* Optional menügeführtes Auspacken des Paketes mit der Möglichkeit Vorgaben zu ändern.

* Informationen über die im Paket enthaltene Produktversion, Paketversion und eventueller kundenspezifischer Erweiterungen werden abgespeichert und sind am Paketnamen erkennbar. Diese werden im Installationsverzeichnis abgelegt und im opsi-Configeditor angezeigt. Auf diese Weise wird der Überblick über unterschiedliche Versionen erleichtert (Productlifecycle Management).

* Zur Erstellung und zum Auspacken von Produkten sind keine root-Rechte erforderlich. Es langen hierzu die Rechte der Gruppe `pcpatch`.

Das Paket selber besteht aus einem per Gzip komprimierten cpio Archiv. In diesem Archiv befinden sich zwei Verzeichnisse:

*CLIENT_DATA* +
Hier liegen die Dateien, die im opsi-Depot (`/var/lib/opsi/depot/<productid>`) für die Clients verfügbar sein sollen.

*OPSI* +
In der Datei `control` finden sich die Metadaten des Produkts wie der Name, die Version oder auch Produkt-Abhängigkeiten.
Weiterhin finden sich im Verzeichnis `OPSI` die Skripte `preinst` und `postinst`, die vor bzw. nach der Installation
des Produkt-Pakets auf einem {opsi-depotserver} ausgeführt werden.
Hier können Sie, wenn benötigt, entsprechende Erweiterungen unterbringen.

[[opsi-getting-started-softwintegration-create-opsi-package-handling]]
==== Erstellen, Packen und Auspacken eines neuen Produktes

Zum Erstellen eines Produktes müssen Sie sich auf dem Server einloggen
(von Windows aus z.B. per `putty.exe` http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).

Die wesentlichen Befehle zum Erstellen und Installieren eines opsi-Produktes sind:

* `opsi-newprod`
* `opsi-makepackage`
* `opsi-package-manager -i <opsi-product-file>`

Zum Erstellen eines neuen Produktes benötigt man mindestens die Rechte der Gruppe +pcpatch+.

Opsi unterstützt die parallele Kompression mittels `pigz`, sofern dieses mindestens in Version 2.2.3 vorliegt. Ist diese oder eine höhere Version installiert, so wird opsi diese automatisch zur (De-)Kompression von Produkten verwenden.
Bitte beachten Sie dabei, dass sowohl `gzip` als auch `pigz` Archive erstellen, welche von der bandbreitenschonenden Synchronisierung mittels `rsync` profitieren können, allerdings sind die Dateien nicht bit-kompatibel. Das bedeutet, dass falls bereits Produkte mittels `gzip` komprimiert und an ein anderes Depot übertragen wurden, nun aber ein mittels `pigz` komprimiertes Paket übertragen wird, mehr als nur die eigentlichen Deltas übertragen werden. Das ist nur bei der ersten Umstellung des verwendeten Komprimierungsprogramms der Fall, bei alle nachfolgenden Übertragungen werden wiederum nur die Unterschiede übertragen.
Um die Verwendung von `pigz` auf einem Server explizit zu deaktivieren, setzen Sie bitte den Wert `use_pigz` in der Sektion `packages` in der Datei `/etc/opsi/opsi.conf` wie nachfolgend gezeigt auf `False`:

[source,configfile]
----
[packages]
use_pigz = False
----

Sie sollten die Produkte in dem Verzeichnis `/var/lib/opsi/workbench` erstellen,
welches der Gruppe +pcpatch+ gehört und die Rechte 2770 hat (Setgroupid Bit für Gruppe +pcpatch+ gesetzt),
sowie als Share `opsi_workbench` freigegeben ist.


[[opsi-getting-started-softwintegration-create-opsi-package-newprod]]
===== Erstellen mit opsi-newprod

Zum Erstellen wechselt man in dieses Verzeichnis und ruft `opsi-newprod` auf.
Das Programm fragt daraufhin nach dem Typ des zu erstellenden Paketes.
Dies ist üblicherweise der Typ +localboot+ für Produkte, die über den '{opsi-client-agent}'/'{opsi-winst}' installiert werden.
Der Typ +netboot+ steht für Produkte, die über das opsi-Linux-Bootimage ausgeführt werden (wie z.B. die Betriebssystem-Installationen).

.Auswahl des Produkttyps: localboot
image::newprod-localboot.png[Screenshot: Auswahl des Produkttyps: localboot]

Wählen Sie nun mit Tab OK (oder bestätigen mit F12). Nun müssen Sie die wesentlichen Produktdaten eingeben. Am oberen Rand ist hierzu eine Hilfe, die erläutert was die Felder bedeuten.

.Eingabe der Produktinformationen
image::newprod-product-info.png[Screenshot: Eingabe der Produktinformationen]

Product Id:: ist ein eindeutiger Bezeichner für das Produkt in der Regel unabhängig von der Version +
Bitte nur Kleinbuchstaben verwenden, keine Umlaute, keine Leerzeichen, keine Sonderzeichen - '-' ist als Trenner erlaubt.

Product name:: ist der Klartextname des Produkts (wir empfehlen die Vermeidung von Umlauten, '-' ist erlaubt, keine Leerzeichen).

Description:: ist eine ergänzende Beschreibung zum Produkt, die z.B. im opsi-Configeditor unter `Beschreibung` angezeigt wird.

Advice:: ist eine ergänzende Beschreibung, in der Regel zum Umgang mit dem Produkt, die zu beachten ist und im opsi-Configeditor unter `Notiz` angezeigt wird.

Product version:: ist die Version der eingepackten Software (max. 32 Zeichen).

Package Version:: ist die Version des Paketes für die Produktversion. Sie dient dazu, Pakete mit gleicher Produktversion, aber z.B. korrigiertem opsi-winst-Skript zu unterscheiden.

License required:: hat bei localboot Produkten keinen Einfluss. Bei netboot Produkten entscheidet diese Option, ob ein Lizenzkey aus dem Lizenzmanagement geholt wird.

Priority:: beeinflusst die Installationsreihenfolge. Mögliche Werte liegen zwischen 100 (ganz am Anfang) und -100 (ganz am Ende). Existieren auch Produktabhängigkeiten, so beeinflussen diese zusätzlich die Installationsreihenfolge.

.Eingabe der opsi-winst-Skript Namen für unterschiedliche Aktionen
image::newprod-script-names.png[Screenshot: Eingabe der opsi-winst-Skript Namen für unterschiedliche Aktionen]

Nach Eingabe der Produktinformationen werden Sie aufgefordert, die Skripte anzugeben, die Sie für die unterschiedlichen möglichen Aktionen bereit stellen werden.

Üblicherweise heißt das *+Setup script+* gleich `setup.ins`.

Üblicherweise heißt das *+Uninstall script+* gleich `uninstall.ins`.

Ein *+Update-Script+* dient zur geringfügigen Veränderung einer existierenden großen Installation. Wird das Produkt auf setup gestellt, so wird nach dem Abarbeiten des Setup-Skriptes automatisch auch das Update-Skript ausgeführt.

Ein *+Always-Script+* wird bei jedem aktiv werden des opsi-Clientagenten ausgeführt (z.B. bei jedem Boot).

Ein *+Once-Script+* hat den Folgestatus `not_installed`. Es handelt sich hierbei um einen sehr selten verwendeten Schalter, den Sie ignorieren sollten, wenn Sie nicht genau wissen, was Sie damit tun wollen.

Ein *+Custom-Script+* verändert weder Folgeaktion noch Folgestatus. Es handelt sich hierbei um einen sehr selten verwendeten Schalter, den Sie ignorieren sollten, wenn Sie nicht genau wissen, was Sie damit tun wollen.

Ein *+userLoginScript+* dient dazu nach dem Login des users Modifikationen am Profil des eingeloggten users vorzunehmen. Dies Funktioniert nur im Zusammenhang mit der opsi Erweiterung 'User Profile Management' und ist im entsprechenden Kapitel des opsi-Handbuchs beschrieben.


|=======================
| Typ | Folgestatus | Folgeaktion
| setup | installed | none
| uninstall | not_installed | none
| update | installed | none
| always | installed | always
| once | not_installed | none
| custom | _unverändert_ | _unverändert_
| User login | _unverändert_ | _unverändert_
|=======================

Nachdem nun das Produkt selber beschrieben ist, können Sie eine oder mehrere Produktabhängigkeiten definieren. Wollen Sie keine Produktabhängigkeit definieren so geben Sie +No+ ein.

.Eine (weitere) Produktabhängigkeit definieren: Ja / Nein
image::newprod-product-new-dependency.png["Screenshot: Eine (weitere) Produktabhängigkeit definieren: Ja / Nein",width=400]

Zur Erstellung einer Produktabhängigkeit geben Sie die folgenden Daten an. Beachten Sie auch die Hilfe im oberen Teil des Fensters:

.Eingabe der Daten zur Erstellung einer Produktabhängigkeit
image::newprod-product-dependency.png["Screenshot: Eingabe der Daten zur Erstellung einer Produktabhängigkeit",width=400]

Dependency for Action:: Für welche Aktion des Produktes, welches Sie gerade erstellen, soll die Abhängigkeit gelten (setup, deinstall ...).

Required product id:: Productid (Bezeichner) des Produkts zu dem eine Abhängigkeit besteht.

Required  action:: Sie können entweder eine Aktion anfordern oder (siehe unten) einen Status. Aktionen können z.B. sein : setup, uninstall, update ...

Required installation status:: Status den das Produkt, zu dem eine Abhängigkeit besteht, haben soll (typischerweise +installed+). Liegt ein anderer Status vor, so wird das Produkt auf +setup+ gestellt.

Requirement type:: Installationsreihenfolge. Wenn das Produkt, zu dem eine Abhängigkeit besteht, installiert sein muss bevor mit der Installation des aktuellen Produkts begonnen werden kann, dann ist dies +before+. Muss es nach dem aktuellen Produkt installiert werden so ist dies +after+. Ist die Reihenfolge egal so muss hier nichts eingetragen werden.

*Hinweis:*

Leider gibt es derzeit keinen generischen Mechanismus für Deinstallations-Produktabhängigkeiten. Zuverlässig ist der ProductDependency-Mechanismus nur für action: setup und die hierbei zu triggernden (before- oder after-) setup Aktionen und installed Status. Ein requiredAction: uninstall führt leider definitiv zu Fehlern.

Nachdem eine Produktabhängigkeit definiert ist, werden Sie wieder gefragt, ob Sie eine (weitere) Produktabhängigkeit definieren wollen. Wenn ja, wiederholt sich der Vorgang; wenn nein, so werden Sie gefragt, ob Sie eine Produkteigenschaft (Zusatzschalter) definieren wollen mit dem Sie die Installation des Produktes modifizieren können.

*Noch ein Hinweis:*

Die tatsächliche Installationsreihenfolge ermittelt sich aus einer Kombination von Produktabhängigkeiten und Produktpriorisierung. Details hierzu finden Sie im opsi-Handbuch im Kapitel 'Beeinflussung der Installationsreihenfolge durch Prioritäten und Produktabhängigkeiten'

.Eine (weitere) Produkteigenschaft definieren
image::newprod-new-property.png["Screenshot: Eine (weitere) Produkteigenschaft definieren",width=400]

Antworten Sie ja, so müssen Sie die Produkteigenschaft beschreiben:

Die Produkteigenschaft wird clientspezifisch gespeichert und besteht aus einem Namen (key) der verschiedene Werte (Values) zugeordnet bekommen kann und die dann vom opsi-winst-Skript abgefragt werden können.

Zunächst müssen Sie angeben, ob es sich um ein Textwert (unicode) oder um einen logische Wert also wahr/falsch (boolean) handelt. Wenn Sie unsicher sind, wählen Sie +unicode+.

.Datentyp der Produkteigenschaft wählen
image::newprod-property-type.png["Screenshot: Datentyp der Produkteigenschaft wählen",width=400]

Weiterhin wird eine Beschreibung benötigt, die im {opsi-configed} als Hilfe angezeigt wird. Weiterhin müssen Sie, durch Kommas getrennt, alle Werte angeben, die der Key annehmen darf. Wird hier nichts angegeben, so kann später im opsi-Configeditor ein beliebiger Wert eingegeben werden. Über `Editable` (true/false) können Sie entscheiden, ob neben der vorgegebenen Liste auch andere Werte eingegeben werden dürfen.

NOTE: Enthält ein Wert einen Backslash `\`, so muss dieser doppelt angegeben werden. +
Eine Pfadangabe kann beispielsweise wie folgt aussehen: `C:\\temp`

.Beschreibung der Produkteigenschaft
image::newprod-property-desc.png["Screenshot: Beschreibung der Produkteigenschaft",width=400]

Im Folgefenster müssen Sie festlegen, was der Defaultwert dieser Produkteigenschaft ist.

.Festlegung des Defaultwerts der Produkteigenschaft
image::newprod-property-default.png["Screenshot: Festlegung des Defaultwerts der Produkteigenschaft",width=400]

Wenn Sie als Typ 'boolean' wählen, so reduziert sich die Beschreibung auf 'Property name' und 'Property description'.

.Beschreibung eines boolschen Properties
image::newprod-property-boolean.png["Screenshot: Beschreibung eines boolschen Properties",width=400]

Nachdem eine Produkteigenschaft definiert ist, werden Sie wieder gefragt, ob Sie eine (weitere) Produkteigenschaft definieren wollen. Wenn ja, wiederholt sich der Vorgang; wenn nein, so werden Sie als nächstes nach Name und Mail-Adresse gefragt. Diese werden im Changelog des Paketes verwendet und müssen angegeben werden.

.Eingabe der Maintainer Daten
image::newprod-maintainer.png["Screenshot: Eingabe der Maintainer Daten",width=400]

Danach ist das Grundgerüst des Produktes fertig gestellt.

Mit Hilfe des `ls` Befehls finden Sie die oben beschriebene Verzeichnis Struktur. Wechseln Sie in den OPSI-Ordner und setzen Sie erneut den `ls` Befehl ab. Hier befindet sich unter anderem die 'control'-Datei, welche die eben eingegebenen Daten enthält und Ihnen auch die Möglichkeit bietet, diese im Editor zu kontrollieren oder zu modifizieren.

.Beispiel einer 'control' Datei

[source,configfile]
----
[Package]
version: 1
depends:

[Product]
type: localboot
id: mytest
name: My Test
description: A test product
advice:
version: 3.14
priority: 10
licenseRequired: False
productClasses:
setupScript: setup.ins
uninstallScript:
updateScript:
alwaysScript:
onceScript:
customScript:
userLoginScript:

[ProductDependency]
action: setup
requiredProduct: javavm
requiredStatus: installed

[ProductProperty]
type: unicode
name: mytextprop
multivalue: False
editable: True
description: hint
values: ["off", "on"]
default: ["off"]

[ProductProperty]
type: bool
name: myboolprop
description: yes or no
default: False

[Changelog]
mytest (3.14-1) testing; urgency=low

  * Initial package

 -- jane doe <j.doe@opsi.org>  Mi, 14 Jul 2010 12:47:53 +0000
----

Als nächstes müssen Sie das, für das Produkt erstellte, opsi-winst-Skript und die entsprechenden Dateien nach 'CLIENT_DATA' kopieren.

Wenn Sie z.B. das erstellte Skript unter 'c:\test' liegen haben, so mounten Sie '\\<opsiserver\opsi_workbench' z.B. nach 'w:' und kopieren den Inhalt von 'c:\test' in das Verzeichnis 'CLIENT_DATA'.

[[opsi-getting-started-softwintegration-create-opsi-package-makeproductfile]]
===== Packen mit opsi-makepackage

Danach können Sie das Produkt packen. Gehen Sie dazu in das Stammverzeichnis des Produkts und rufen Sie 'opsi-makepackage' auf. Es wird nun das Produkt gepackt.

opsi-makepackage kennt einige Optionen, die sein Verhalten modifizieren:

[source,prompt]
----
$ opsi-makepackage --help
usage: opsi-makepackage [--help] [--version] [--quiet] [--verbose]
                        [--log-level {0,1,2,3,4,5,6,7,8,9}] [--no-compression]
                        [--archive-format {cpio,tar}] [--follow-symlinks]
                        [--custom-name custom name | --custom-only custom name]
                        [--temp-directory directory] [--md5 | --no-md5]
                        [--zsync | --no-zsync] [--no-pigz] [--keep-versions]
                        [--package-version packageversion]
                        [--product-version productversion]
                        [source directory]

Provides an opsi package from a package source directory. If no source
directory is supplied, the current directory will be used.

positional arguments:
  source directory

optional arguments:
  --help                Show help.
  --version, -V         show program's version number and exit
  --quiet, -q           do not show progress
  --verbose, -v         verbose
  --log-level {0,1,2,3,4,5,6,7,8,9}, -l {0,1,2,3,4,5,6,7,8,9}
                        Set log-level (0..9)
  --no-compression, -n  Do not compress
  --archive-format {cpio,tar}, -F {cpio,tar}
                        Archive format to use. Default: cpio
  --follow-symlinks, -h
                        follow symlinks
  --custom-name custom name, -i custom name
                        custom name (add custom files)
  --custom-only custom name, -c custom name
                        custom name (custom only)
  --temp-directory directory, -t directory
                        temp dir
  --md5, -m             Create file with md5 checksum.
  --no-md5              Do not create file with md5 checksum.
  --zsync, -z           Create zsync file.
  --no-zsync            Do not create zsync file.
  --no-pigz             Disable the usage of pigz

Versions:
  Set versions for package. Combinations are possible.

  --keep-versions, -k   Keep versions and overwrite package
  --package-version packageversion
                        Set new package version
  --product-version productversion
                        Set new product version for package
----

Es ist zu empfehlen die Pakete gleich mit einer zugehörigen md5-Prüfsummendatei zu erstellen.
Diese Datei wird unter anderem vom `opsi-package-updater` genutzt, um nach der Paketübertragung die Paketintegrität sicher zu stellen.
Eine solche Datei wird automatisch erstellt, aber für besondere Einsatzszenarien kann die Erstellung unterdrückt werden.

Bei der Übertragung von Paketen auf {opsi-depotserver} kann auf 'zsync' zurück gegriffen werden, um nur Unterschiede zwischen verschiedenen Paketen zu übertragen.
Damit dieses Verfahren verwendet werde kann, wird eine Datei besondere `.zsync`-Datei benötigt.
Eine solche Datei wird automatisch erstellt, aber für besondere Einsatzszenarien kann die Erstellung unterdrückt werden.

Wenn es beim Erstellen großer Pakete zu Platzproblemen im temporären Verzeichnis `/tmp` kommt, ist es möglich mittels `--temp-directory` ein abweichendes temporäres Verzeichnis anzugeben.

Wenn schon ein Paket dieser Version existiert, so zeigt `opsi-makepackage` eine Rückfrage:

[source,prompt]
----
Package file '/var/lib/opsi/workbench/mytest/mytest_3.14-1.opsi' already exists.
Press <O> to overwrite, <C> to abort or <N> to specify a new version:
----

Mit `o` wählen Sie überschreiben, mit `c` brechen Sie den Vorgang ab und mit `n` können Sie wählen, dass Sie nach einer neuen Product- bzw. Package-Version gefragt werden.

Das gepackte Paket können Sie mit `opsi-package-manager --install <paketdatei>` auf dem Server installieren.

Weitere Informationen zum opsi-packet-manager siehe opsi-Handbuch.


[[opsi-getting-started-more-info]]
== Weitere Informationen

Das opsi-Handbuch (http://download.uib.de/opsi_stable/doc/opsi-handbuch-stable-de.pdf) enthält eine Fülle von weiteren Informationen, die für den produktiven Betrieb wichtig sind.

Wenn Sie dort nicht fündig werden oder Hilfe benötigen, wenden Sie sich an +
https://forum.opsi.org

Für produktive Installationen empfehlen wir professionelle Unterstützung durch uib im Rahmen eines Pflege- und Supportvertrages: +
http://uib.de/de/support-schulung/support/
